/**
 * vue-meta v3.0.0-alpha.2
 * (c) 2021
 * - Pim (@pimlie)
 * - All the amazing contributors
 * @license MIT
 */
import{markRaw as t,h as e,getCurrentInstance as o,isProxy as r,watch as n,inject as s,defineComponent as i,reactive as c,onUnmounted as a,Teleport as u,Comment as l}from"vue";const f=t=>(e,o)=>{let r=-1;if(o.reduce(((e,o,n)=>{const s=t(e,o);return s!==e?(r=n,s):e}),void 0),r>-1)return e[r]};const d=f(((t,e)=>{const{depth:o}=e;if(!t||o>t)return t}));var p=Object.freeze({__proto__:null,setup:function(t){let e=0;if(t.vm){let{vm:o}=t;do{o.parent&&(e++,o=o.parent)}while(o&&o.parent&&o!==o.root)}t.depth=e},resolve:d});const m={body:{tag:"script",to:"body"},base:{valueAttribute:"href"},charset:{tag:"meta",nameless:!0,valueAttribute:"charset"},description:{tag:"meta"},og:{group:!0,namespacedAttribute:!0,tag:"meta",keyAttribute:"property"},twitter:{group:!0,namespacedAttribute:!0,tag:"meta"},htmlAttrs:{attributesFor:"html"},headAttrs:{attributesFor:"head"},bodyAttrs:{attributesFor:"body"}},b={title:{attributes:!1},base:{contentAsAttribute:!0,attributes:["href","target"]},meta:{contentAsAttribute:!0,keyAttribute:"name",attributes:["content","name","http-equiv","charset"]},link:{contentAsAttribute:!0,attributes:["href","crossorigin","rel","media","integrity","hreflang","type","referrerpolicy","sizes","imagesrcset","imagesizes","as","color"]},style:{attributes:["media"]},script:{attributes:["src","type","nomodule","async","defer","crossorigin","integrity","referrerpolicy"]},noscript:{attributes:!1}};"production"===process.env.NODE_ENV||Object.freeze({}),"production"===process.env.NODE_ENV||Object.freeze([]);const h=Array.isArray,y=t=>"function"==typeof t,g=t=>"string"==typeof t,v=t=>null!==t&&"object"==typeof t,A=Object.prototype.toString,S=t=>"[object Object]"===A.call(t),N=Symbol("kIsProxy"),k=Symbol("kProxySources"),w=Symbol("kProxyTarget"),O=Symbol("kResolveContext");function j(t){if(h(t))return t.map(j);if(v(t)){const e={};for(const o in t)e[o]="context"===o?t[o]:j(t[o]);return e}return t}const x=(t,e,o)=>{const r=[];for(const n of t)e in n&&(r.push(n[e]),o&&o(n));return r},$=(t,e,o,r=[])=>{if(r.length||(o||(o=t.active),e||(e=t.sources)),!o||!e)return;const n=((t,...e)=>{const o=t?Object.keys(t):[];if(e)for(const t of e)if(t&&v(t))for(const e in t)o.includes(e)||o.push(e);return o})(...e),s=Object.keys(o);for(const t of s)n.includes(t)||delete o[t];for(const s of n){if(S(e[0][s])){o[s]||(o[s]={});const n=[];for(const t of e)s in t&&n.push(t[s]);$(t,n,o[s],[...r,s]);continue}!o[s]&&h(e[0][s])&&(o[s]=[]);const n=[],i=x(e,s,(t=>n.push(t[O])));let c=t.resolve(i,n,o[s],s,r);S(c)&&(c=j(c)),o[s]=c}},P=(e,o,r,n=[])=>{const s=C(e,r,n),i=t(new Proxy(o,s));return!n.length&&e.sources&&e.sources.push(i),i},C=(t,e,o=[])=>({get:(r,n,s)=>{if(n===N)return!0;if(n===k)return t.sources;if(n===w)return r;if(n===O)return e;let i=Reflect.get(r,n,s);if(!v(i))return i;if(!i[N]){const s=[...o,n];i=P(t,i,e,s),r[n]=i}return i},set:(e,r,n)=>{const s=Reflect.set(e,r,n);if(s){const n=h(e);let i,c=!1,{sources:a,active:u}=t,l=0;for(const t of o){if(a=x(a,t),n&&l===o.length-1){i=t;break}h(u)&&(c=!0),u=u[t],l++}if(c)return $(t),s;let f,d=[];n?(f=a,d=a.map((t=>t[O]))):f=x(a,r,(t=>d.push(t[O])));let p=t.resolve(f,d,u,r,o);S(p)&&(p=j(p)),n&&i?u[i]=p:u[r]=p}return s},deleteProperty:(e,r)=>{const n=Reflect.deleteProperty(e,r);if(n){const n=h(e);let s,i=t.sources,c=t.active,a=0;for(const t of o){if(i=i.map((e=>e[t])),n&&a===o.length-1){s=t;break}c=c[t],a++}if(i.some((t=>r in t))){let e,a=[];n?(e=i,a=i.map((t=>t[O]))):e=x(i,r,(t=>a.push(t[O])));let u=t.resolve(e,a,c,r,o);S(u)&&(u=j(u)),n&&s?c[s]=u:c[r]=u}else delete c[r]}return n}}),E={};function M(t,e,o,r){return"attributesFor"in r?function(t,e,o,r){const{attributesFor:n}=r;if(!n)return;if(!E[n]){const[t,e]=Array.from(document.querySelectorAll(n));if(!t)return void console.error("Could not find element for selector",n,", won't render attributes");e&&console.warn("Found multiple elements for selector",n),E[n]={el:t,attrs:[]}}const{el:s,attrs:i}=E[n];for(const r in o){const n=_(t,`${e}(${r})`,o[r],o);s.setAttribute(r,n||""),i.includes(r)||i.push(r)}const c=i.filter((t=>!o[t]));for(const t of c)s.removeAttribute(t)}(t,e,o,r):"group"in r?function(t,e,o,r){if(h(o))return console.warn("Specifying an array for group properties isnt supported"),[];return Object.keys(o).map((n=>{const s={group:e,data:o};if(r.namespaced)s.tagNamespace=!0===r.namespaced?e:r.namespaced;else if(r.namespacedAttribute){const t=!0===r.namespacedAttribute?e:r.namespacedAttribute;s.fullName=`${t}:${n}`,s.slotName=`${t}(${n})`}return F(t,e,o[n],r,s)})).flat()}(t,e,o,r):F(t,e,o,r)}function F(t,o,r,n={},s){const i=["content","json","rawContent"],c=t=>function(t,e){for(const o of t){const t=b[o];if(o&&t)return t[e]}}([a,n.tag],t);if(h(r))return r.map((e=>F(t,o,e,n,s))).flat();const{tag:a=n.tag||o}=r;let u="",l=!1,f=!1;if(g(r))u=r;else if(r.children&&h(r.children))l=!0,u=r.children.map((e=>{const r=F(t,o,e,n,s);return h(r)?r.map((({vnode:t})=>t)):r.vnode}));else{let t=0;for(const e of i){if(!u&&r[e]){u=1===t?JSON.stringify(r[e]):r[e],f=t>1;break}t++}}const d=s&&s.fullName||o,p=s&&s.slotName||o;let{attrs:m}=r;if(m||"object"!=typeof r)m||(m={});else{m={...r},delete m.tag,delete m.children,delete m.to;for(const t of i)delete m[t]}if(l)u=_(t,p,u,r);else{const e=!!c("contentAsAttribute");let{valueAttribute:o}=n;if(!o&&e){const[t]=c("attributes");o=g(e)?e:t}if(o){const{nameless:e,keyAttribute:r}=n;e||r&&(m[r]=d),m[o]=_(t,p,m[o]||u,s),u=""}else u=_(t,p,u,r)}const y=s&&s.tagNamespace?`${s.tagNamespace}:${a}`:a;f&&u&&(m.innerHTML=u);const v=e(y,m,u||void 0);return{to:r.to,vnode:v}}function _({metainfo:t,slots:e},o,r,n){const s=e&&e[o];if(!s||!y(s))return r;const i={content:r,metainfo:t};if(n&&n.group){const{group:t,data:e}=n;i[t]=e}const c=s(i);if(c&&c.length){const{children:t}=c[0];return t?t.toString():""}return r}const R="function"==typeof Symbol&&"symbol"==typeof Symbol.toStringTag,U=(t=>R?Symbol("[vue-meta]: "+t):"[vue-meta]: "+t)("meta_active");function z(t){if(t||(t=o()||void 0),t)return t.appContext.config.globalProperties.$metaManager}function L(t,e){const s=o()||void 0;if(!e&&s&&(e=z(s)),!e)throw new Error("No manager or current instance");r(t)&&(n(t,((t,e)=>{!function(t,e,o){for(const r in e)r in o?v(t[r])||e[r]!==o[r]&&(t[r]=e[r]):t[r]=e[r];for(const r in o)r in e||delete t[r]}(i.meta,t,e)})),t=t.value);const i=e.addMeta(t,s);return i}function q(){return s(U)}const D=i({name:"Metainfo",inheritAttrs:!1,setup:(t,{slots:e})=>()=>{const t=z();if(t)return t.render({slots:e})}}),T=c({});function I(t,e,o){const r=h(o)?o:[o];r.forEach(((t,e)=>{t.type===l&&r.splice(e,1)})),t[e]||(t[e]=[]),t[e].push(...r)}const V=(t,e)=>H.create(t,e);class H{constructor(t,e,o){this.ssrCleanedUp=!1,this.config=t,this.target=e,o&&"setup"in o&&y(o.setup)&&(this.resolver=o)}install(t){t.component("Metainfo",D),t.config.globalProperties.$metaManager=this,t.provide(U,T)}addMeta(t,e){e||(e=o()||void 0);const r={removed:[]},n={vm:e};this.resolver&&this.resolver.setup(n);const s=this.target.addSource(t,n,!0),i=t=>this.unmount(!!t,s,r,e);return e&&a(i),{meta:s,onRemoved:t=>r.removed.push(t),unmount:i}}unmount(t,e,o,r){if(r){const{$el:n}=r.proxy;if(n&&n.offsetParent){let r=new MutationObserver((s=>{for(const{removedNodes:i}of s)i&&i.forEach((s=>{s===n&&r&&(r.disconnect(),r=void 0,this.reallyUnmount(t,e,o))}))}));return void r.observe(n.parentNode,{childList:!0})}}this.reallyUnmount(t,e,o)}async reallyUnmount(t,e,o){this.target.delSource(e),!t&&o&&await Promise.all(o.removed.map((t=>t())))}render({slots:t}={}){this.ssrCleanedUp||(this.ssrCleanedUp=!0,window.addEventListener("DOMContentLoaded",(()=>{const t=document.querySelectorAll("[data-vm-ssr]");t&&t.length&&Array.from(t).forEach((t=>t.parentNode&&t.parentNode.removeChild(t)))})));const o={};for(const e in T){const r=this.config[e]||{};let n=M({metainfo:T,slots:t},e,T[e],r);if(!n)continue;h(n)||(n=[n]);let s="base"!==e&&T[e].to;!s&&"to"in r&&(s=r.to),!s&&"attributesFor"in r&&(s=e);for(const{to:t,vnode:e}of n)I(o,t||s||"head",e)}if(t)for(const e in t){const r="default"===e?"head":e;if("head"!==r&&"body"!==r)continue;const n=t[e];y(n)&&I(o,r,n({metainfo:T}))}return Object.keys(o).map((t=>e(u,{to:t},o[t])))}}H.create=(t,e)=>{const o=((t,e={})=>{const o=[];e||(e={});const r={active:e,resolve:t,sources:o},n=()=>$(r);return{context:r,compute:n,addSource:(t,e,o=!1)=>{const s=P(r,t,e||{});return o&&n(),s},delSource:(t,e=!0)=>{const r=o.findIndex((e=>e===t||e[w]===t));return r>-1&&(o.splice(r,1),e&&n(),!0)}}})(((t,o,r,n,s)=>y(e)?e(t,o,r,n,s):e.resolve(t,o,r,n,s)),T);return new H(t,o,e)};export{V as createMetaManager,p as deepestResolver,m as defaultConfig,z as getCurrentManager,f as resolveOption,q as useActiveMeta,L as useMeta};
