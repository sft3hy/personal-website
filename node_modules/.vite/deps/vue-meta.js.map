{
  "version": 3,
  "sources": ["../../@vue/server-renderer/dist/server-renderer.esm-bundler.js", "../../vue-meta/dist/vue-meta.esm-bundler.js"],
  "sourcesContent": ["/**\n* @vue/server-renderer v3.4.38\n* (c) 2018-present Yuxi (Evan) You and Vue contributors\n* @license MIT\n**/\nimport { createVNode, ssrUtils, ssrContextKey, warn as warn$2, Fragment, Static, Comment, Text, mergeProps, createApp, initDirectivesForSSR } from 'vue';\nimport { isOn, isRenderableAttrValue, isSVGTag, propsToAttrMap, isBooleanAttr, includeBooleanAttr, isSSRSafeAttrName, escapeHtml, normalizeClass, isString, normalizeStyle, stringifyStyle, makeMap, isArray, toDisplayString, extend, isFunction, getGlobalThis, NOOP, isObject, looseEqual, looseIndexOf, isPromise, escapeHtmlComment, isVoidTag } from '@vue/shared';\nexport { includeBooleanAttr as ssrIncludeBooleanAttr } from '@vue/shared';\n\nconst shouldIgnoreProp = /* @__PURE__ */ makeMap(\n  `,key,ref,innerHTML,textContent,ref_key,ref_for`\n);\nfunction ssrRenderAttrs(props, tag) {\n  let ret = \"\";\n  for (const key in props) {\n    if (shouldIgnoreProp(key) || isOn(key) || tag === \"textarea\" && key === \"value\") {\n      continue;\n    }\n    const value = props[key];\n    if (key === \"class\") {\n      ret += ` class=\"${ssrRenderClass(value)}\"`;\n    } else if (key === \"style\") {\n      ret += ` style=\"${ssrRenderStyle(value)}\"`;\n    } else {\n      ret += ssrRenderDynamicAttr(key, value, tag);\n    }\n  }\n  return ret;\n}\nfunction ssrRenderDynamicAttr(key, value, tag) {\n  if (!isRenderableAttrValue(value)) {\n    return ``;\n  }\n  const attrKey = tag && (tag.indexOf(\"-\") > 0 || isSVGTag(tag)) ? key : propsToAttrMap[key] || key.toLowerCase();\n  if (isBooleanAttr(attrKey)) {\n    return includeBooleanAttr(value) ? ` ${attrKey}` : ``;\n  } else if (isSSRSafeAttrName(attrKey)) {\n    return value === \"\" ? ` ${attrKey}` : ` ${attrKey}=\"${escapeHtml(value)}\"`;\n  } else {\n    console.warn(\n      `[@vue/server-renderer] Skipped rendering unsafe attribute name: ${attrKey}`\n    );\n    return ``;\n  }\n}\nfunction ssrRenderAttr(key, value) {\n  if (!isRenderableAttrValue(value)) {\n    return ``;\n  }\n  return ` ${key}=\"${escapeHtml(value)}\"`;\n}\nfunction ssrRenderClass(raw) {\n  return escapeHtml(normalizeClass(raw));\n}\nfunction ssrRenderStyle(raw) {\n  if (!raw) {\n    return \"\";\n  }\n  if (isString(raw)) {\n    return escapeHtml(raw);\n  }\n  const styles = normalizeStyle(raw);\n  return escapeHtml(stringifyStyle(styles));\n}\n\nfunction ssrRenderComponent(comp, props = null, children = null, parentComponent = null, slotScopeId) {\n  return renderComponentVNode(\n    createVNode(comp, props, children),\n    parentComponent,\n    slotScopeId\n  );\n}\n\nconst { ensureValidVNode } = ssrUtils;\nfunction ssrRenderSlot(slots, slotName, slotProps, fallbackRenderFn, push, parentComponent, slotScopeId) {\n  push(`<!--[-->`);\n  ssrRenderSlotInner(\n    slots,\n    slotName,\n    slotProps,\n    fallbackRenderFn,\n    push,\n    parentComponent,\n    slotScopeId\n  );\n  push(`<!--]-->`);\n}\nfunction ssrRenderSlotInner(slots, slotName, slotProps, fallbackRenderFn, push, parentComponent, slotScopeId, transition) {\n  const slotFn = slots[slotName];\n  if (slotFn) {\n    const slotBuffer = [];\n    const bufferedPush = (item) => {\n      slotBuffer.push(item);\n    };\n    const ret = slotFn(\n      slotProps,\n      bufferedPush,\n      parentComponent,\n      slotScopeId ? \" \" + slotScopeId : \"\"\n    );\n    if (isArray(ret)) {\n      const validSlotContent = ensureValidVNode(ret);\n      if (validSlotContent) {\n        renderVNodeChildren(\n          push,\n          validSlotContent,\n          parentComponent,\n          slotScopeId\n        );\n      } else if (fallbackRenderFn) {\n        fallbackRenderFn();\n      }\n    } else {\n      let isEmptySlot = true;\n      if (transition) {\n        isEmptySlot = false;\n      } else {\n        for (let i = 0; i < slotBuffer.length; i++) {\n          if (!isComment(slotBuffer[i])) {\n            isEmptySlot = false;\n            break;\n          }\n        }\n      }\n      if (isEmptySlot) {\n        if (fallbackRenderFn) {\n          fallbackRenderFn();\n        }\n      } else {\n        let start = 0;\n        let end = slotBuffer.length;\n        if (transition && slotBuffer[0] === \"<!--[-->\" && slotBuffer[end - 1] === \"<!--]-->\") {\n          start++;\n          end--;\n        }\n        for (let i = start; i < end; i++) {\n          push(slotBuffer[i]);\n        }\n      }\n    }\n  } else if (fallbackRenderFn) {\n    fallbackRenderFn();\n  }\n}\nconst commentTestRE = /^<!--[\\s\\S]*-->$/;\nconst commentRE = /<!--[^]*?-->/gm;\nfunction isComment(item) {\n  if (typeof item !== \"string\" || !commentTestRE.test(item)) return false;\n  if (item.length <= 8) return true;\n  return !item.replace(commentRE, \"\").trim();\n}\n\nfunction ssrRenderTeleport(parentPush, contentRenderFn, target, disabled, parentComponent) {\n  parentPush(\"<!--teleport start-->\");\n  const context = parentComponent.appContext.provides[ssrContextKey];\n  const teleportBuffers = context.__teleportBuffers || (context.__teleportBuffers = {});\n  const targetBuffer = teleportBuffers[target] || (teleportBuffers[target] = []);\n  const bufferIndex = targetBuffer.length;\n  let teleportContent;\n  if (disabled) {\n    contentRenderFn(parentPush);\n    teleportContent = `<!--teleport start anchor--><!--teleport anchor-->`;\n  } else {\n    const { getBuffer, push } = createBuffer();\n    push(`<!--teleport start anchor-->`);\n    contentRenderFn(push);\n    push(`<!--teleport anchor-->`);\n    teleportContent = getBuffer();\n  }\n  targetBuffer.splice(bufferIndex, 0, teleportContent);\n  parentPush(\"<!--teleport end-->\");\n}\n\nfunction ssrInterpolate(value) {\n  return escapeHtml(toDisplayString(value));\n}\n\nlet activeEffect;\nlet shouldTrack = true;\nconst trackStack = [];\nfunction pauseTracking() {\n  trackStack.push(shouldTrack);\n  shouldTrack = false;\n}\nfunction resetTracking() {\n  const last = trackStack.pop();\n  shouldTrack = last === void 0 ? true : last;\n}\nfunction trackEffect(effect2, dep, debuggerEventExtraInfo) {\n  var _a;\n  if (dep.get(effect2) !== effect2._trackId) {\n    dep.set(effect2, effect2._trackId);\n    const oldDep = effect2.deps[effect2._depsLength];\n    if (oldDep !== dep) {\n      effect2.deps[effect2._depsLength++] = dep;\n    } else {\n      effect2._depsLength++;\n    }\n    if (!!(process.env.NODE_ENV !== \"production\")) {\n      (_a = effect2.onTrack) == null ? void 0 : _a.call(effect2, extend({ effect: effect2 }, debuggerEventExtraInfo));\n    }\n  }\n}\n\nconst createDep = (cleanup, computed) => {\n  const dep = /* @__PURE__ */ new Map();\n  dep.cleanup = cleanup;\n  dep.computed = computed;\n  return dep;\n};\n\nconst targetMap = /* @__PURE__ */ new WeakMap();\nSymbol(!!(process.env.NODE_ENV !== \"production\") ? \"iterate\" : \"\");\nSymbol(!!(process.env.NODE_ENV !== \"production\") ? \"Map key iterate\" : \"\");\nfunction track(target, type, key) {\n  if (shouldTrack && activeEffect) {\n    let depsMap = targetMap.get(target);\n    if (!depsMap) {\n      targetMap.set(target, depsMap = /* @__PURE__ */ new Map());\n    }\n    let dep = depsMap.get(key);\n    if (!dep) {\n      depsMap.set(key, dep = createDep(() => depsMap.delete(key)));\n    }\n    trackEffect(\n      activeEffect,\n      dep,\n      !!(process.env.NODE_ENV !== \"production\") ? {\n        target,\n        type,\n        key\n      } : void 0\n    );\n  }\n}\n\nfunction toRaw(observed) {\n  const raw = observed && observed[\"__v_raw\"];\n  return raw ? toRaw(raw) : observed;\n}\n\nfunction isRef(r) {\n  return !!(r && r.__v_isRef === true);\n}\n\nconst stack = [];\nfunction pushWarningContext(vnode) {\n  stack.push(vnode);\n}\nfunction popWarningContext() {\n  stack.pop();\n}\nlet isWarning = false;\nfunction warn$1(msg, ...args) {\n  if (isWarning) return;\n  isWarning = true;\n  pauseTracking();\n  const instance = stack.length ? stack[stack.length - 1].component : null;\n  const appWarnHandler = instance && instance.appContext.config.warnHandler;\n  const trace = getComponentTrace();\n  if (appWarnHandler) {\n    callWithErrorHandling(\n      appWarnHandler,\n      instance,\n      11,\n      [\n        // eslint-disable-next-line no-restricted-syntax\n        msg + args.map((a) => {\n          var _a, _b;\n          return (_b = (_a = a.toString) == null ? void 0 : _a.call(a)) != null ? _b : JSON.stringify(a);\n        }).join(\"\"),\n        instance && instance.proxy,\n        trace.map(\n          ({ vnode }) => `at <${formatComponentName(instance, vnode.type)}>`\n        ).join(\"\\n\"),\n        trace\n      ]\n    );\n  } else {\n    const warnArgs = [`[Vue warn]: ${msg}`, ...args];\n    if (trace.length && // avoid spamming console during tests\n    true) {\n      warnArgs.push(`\n`, ...formatTrace(trace));\n    }\n    console.warn(...warnArgs);\n  }\n  resetTracking();\n  isWarning = false;\n}\nfunction getComponentTrace() {\n  let currentVNode = stack[stack.length - 1];\n  if (!currentVNode) {\n    return [];\n  }\n  const normalizedStack = [];\n  while (currentVNode) {\n    const last = normalizedStack[0];\n    if (last && last.vnode === currentVNode) {\n      last.recurseCount++;\n    } else {\n      normalizedStack.push({\n        vnode: currentVNode,\n        recurseCount: 0\n      });\n    }\n    const parentInstance = currentVNode.component && currentVNode.component.parent;\n    currentVNode = parentInstance && parentInstance.vnode;\n  }\n  return normalizedStack;\n}\nfunction formatTrace(trace) {\n  const logs = [];\n  trace.forEach((entry, i) => {\n    logs.push(...i === 0 ? [] : [`\n`], ...formatTraceEntry(entry));\n  });\n  return logs;\n}\nfunction formatTraceEntry({ vnode, recurseCount }) {\n  const postfix = recurseCount > 0 ? `... (${recurseCount} recursive calls)` : ``;\n  const isRoot = vnode.component ? vnode.component.parent == null : false;\n  const open = ` at <${formatComponentName(\n    vnode.component,\n    vnode.type,\n    isRoot\n  )}`;\n  const close = `>` + postfix;\n  return vnode.props ? [open, ...formatProps(vnode.props), close] : [open + close];\n}\nfunction formatProps(props) {\n  const res = [];\n  const keys = Object.keys(props);\n  keys.slice(0, 3).forEach((key) => {\n    res.push(...formatProp(key, props[key]));\n  });\n  if (keys.length > 3) {\n    res.push(` ...`);\n  }\n  return res;\n}\nfunction formatProp(key, value, raw) {\n  if (isString(value)) {\n    value = JSON.stringify(value);\n    return raw ? value : [`${key}=${value}`];\n  } else if (typeof value === \"number\" || typeof value === \"boolean\" || value == null) {\n    return raw ? value : [`${key}=${value}`];\n  } else if (isRef(value)) {\n    value = formatProp(key, toRaw(value.value), true);\n    return raw ? value : [`${key}=Ref<`, value, `>`];\n  } else if (isFunction(value)) {\n    return [`${key}=fn${value.name ? `<${value.name}>` : ``}`];\n  } else {\n    value = toRaw(value);\n    return raw ? value : [`${key}=`, value];\n  }\n}\n\nconst ErrorTypeStrings = {\n  [\"sp\"]: \"serverPrefetch hook\",\n  [\"bc\"]: \"beforeCreate hook\",\n  [\"c\"]: \"created hook\",\n  [\"bm\"]: \"beforeMount hook\",\n  [\"m\"]: \"mounted hook\",\n  [\"bu\"]: \"beforeUpdate hook\",\n  [\"u\"]: \"updated\",\n  [\"bum\"]: \"beforeUnmount hook\",\n  [\"um\"]: \"unmounted hook\",\n  [\"a\"]: \"activated hook\",\n  [\"da\"]: \"deactivated hook\",\n  [\"ec\"]: \"errorCaptured hook\",\n  [\"rtc\"]: \"renderTracked hook\",\n  [\"rtg\"]: \"renderTriggered hook\",\n  [0]: \"setup function\",\n  [1]: \"render function\",\n  [2]: \"watcher getter\",\n  [3]: \"watcher callback\",\n  [4]: \"watcher cleanup function\",\n  [5]: \"native event handler\",\n  [6]: \"component event handler\",\n  [7]: \"vnode hook\",\n  [8]: \"directive hook\",\n  [9]: \"transition hook\",\n  [10]: \"app errorHandler\",\n  [11]: \"app warnHandler\",\n  [12]: \"ref function\",\n  [13]: \"async component loader\",\n  [14]: \"scheduler flush\",\n  [15]: \"component update\"\n};\nfunction callWithErrorHandling(fn, instance, type, args) {\n  try {\n    return args ? fn(...args) : fn();\n  } catch (err) {\n    handleError(err, instance, type);\n  }\n}\nfunction handleError(err, instance, type, throwInDev = true) {\n  const contextVNode = instance ? instance.vnode : null;\n  if (instance) {\n    let cur = instance.parent;\n    const exposedInstance = instance.proxy;\n    const errorInfo = !!(process.env.NODE_ENV !== \"production\") ? ErrorTypeStrings[type] : `https://vuejs.org/error-reference/#runtime-${type}`;\n    while (cur) {\n      const errorCapturedHooks = cur.ec;\n      if (errorCapturedHooks) {\n        for (let i = 0; i < errorCapturedHooks.length; i++) {\n          if (errorCapturedHooks[i](err, exposedInstance, errorInfo) === false) {\n            return;\n          }\n        }\n      }\n      cur = cur.parent;\n    }\n    const appErrorHandler = instance.appContext.config.errorHandler;\n    if (appErrorHandler) {\n      pauseTracking();\n      callWithErrorHandling(\n        appErrorHandler,\n        null,\n        10,\n        [err, exposedInstance, errorInfo]\n      );\n      resetTracking();\n      return;\n    }\n  }\n  logError(err, type, contextVNode, throwInDev);\n}\nfunction logError(err, type, contextVNode, throwInDev = true) {\n  if (!!(process.env.NODE_ENV !== \"production\")) {\n    const info = ErrorTypeStrings[type];\n    if (contextVNode) {\n      pushWarningContext(contextVNode);\n    }\n    warn$1(`Unhandled error${info ? ` during execution of ${info}` : ``}`);\n    if (contextVNode) {\n      popWarningContext();\n    }\n    if (throwInDev) {\n      throw err;\n    } else {\n      console.error(err);\n    }\n  } else {\n    console.error(err);\n  }\n}\n\nlet devtools;\nlet buffer = [];\nfunction setDevtoolsHook(hook, target) {\n  var _a, _b;\n  devtools = hook;\n  if (devtools) {\n    devtools.enabled = true;\n    buffer.forEach(({ event, args }) => devtools.emit(event, ...args));\n    buffer = [];\n  } else if (\n    // handle late devtools injection - only do this if we are in an actual\n    // browser environment to avoid the timer handle stalling test runner exit\n    // (#4815)\n    typeof window !== \"undefined\" && // some envs mock window but not fully\n    window.HTMLElement && // also exclude jsdom\n    // eslint-disable-next-line no-restricted-syntax\n    !((_b = (_a = window.navigator) == null ? void 0 : _a.userAgent) == null ? void 0 : _b.includes(\"jsdom\"))\n  ) {\n    const replay = target.__VUE_DEVTOOLS_HOOK_REPLAY__ = target.__VUE_DEVTOOLS_HOOK_REPLAY__ || [];\n    replay.push((newHook) => {\n      setDevtoolsHook(newHook, target);\n    });\n    setTimeout(() => {\n      if (!devtools) {\n        target.__VUE_DEVTOOLS_HOOK_REPLAY__ = null;\n        buffer = [];\n      }\n    }, 3e3);\n  } else {\n    buffer = [];\n  }\n}\n\n{\n  const g = getGlobalThis();\n  const registerGlobalSetter = (key, setter) => {\n    let setters;\n    if (!(setters = g[key])) setters = g[key] = [];\n    setters.push(setter);\n    return (v) => {\n      if (setters.length > 1) setters.forEach((set) => set(v));\n      else setters[0](v);\n    };\n  };\n  registerGlobalSetter(\n    `__VUE_INSTANCE_SETTERS__`,\n    (v) => v\n  );\n  registerGlobalSetter(\n    `__VUE_SSR_SETTERS__`,\n    (v) => v\n  );\n}\n!!(process.env.NODE_ENV !== \"production\") ? {\n  get(target, key) {\n    track(target, \"get\", \"\");\n    return target[key];\n  },\n  set() {\n    warn$1(`setupContext.attrs is readonly.`);\n    return false;\n  },\n  deleteProperty() {\n    warn$1(`setupContext.attrs is readonly.`);\n    return false;\n  }\n} : {\n  get(target, key) {\n    track(target, \"get\", \"\");\n    return target[key];\n  }\n};\nconst classifyRE = /(?:^|[-_])(\\w)/g;\nconst classify = (str) => str.replace(classifyRE, (c) => c.toUpperCase()).replace(/[-_]/g, \"\");\nfunction getComponentName(Component, includeInferred = true) {\n  return isFunction(Component) ? Component.displayName || Component.name : Component.name || includeInferred && Component.__name;\n}\nfunction formatComponentName(instance, Component, isRoot = false) {\n  let name = getComponentName(Component);\n  if (!name && Component.__file) {\n    const match = Component.__file.match(/([^/\\\\]+)\\.\\w+$/);\n    if (match) {\n      name = match[1];\n    }\n  }\n  if (!name && instance && instance.parent) {\n    const inferFromRegistry = (registry) => {\n      for (const key in registry) {\n        if (registry[key] === Component) {\n          return key;\n        }\n      }\n    };\n    name = inferFromRegistry(\n      instance.components || instance.parent.type.components\n    ) || inferFromRegistry(instance.appContext.components);\n  }\n  return name ? classify(name) : isRoot ? `App` : `Anonymous`;\n}\n\nconst warn = !!(process.env.NODE_ENV !== \"production\") ? warn$1 : NOOP;\n!!(process.env.NODE_ENV !== \"production\") || true ? devtools : void 0;\n!!(process.env.NODE_ENV !== \"production\") || true ? setDevtoolsHook : NOOP;\n\nfunction ssrRenderList(source, renderItem) {\n  if (isArray(source) || isString(source)) {\n    for (let i = 0, l = source.length; i < l; i++) {\n      renderItem(source[i], i);\n    }\n  } else if (typeof source === \"number\") {\n    if (!!(process.env.NODE_ENV !== \"production\") && !Number.isInteger(source)) {\n      warn(`The v-for range expect an integer value but got ${source}.`);\n      return;\n    }\n    for (let i = 0; i < source; i++) {\n      renderItem(i + 1, i);\n    }\n  } else if (isObject(source)) {\n    if (source[Symbol.iterator]) {\n      const arr = Array.from(source);\n      for (let i = 0, l = arr.length; i < l; i++) {\n        renderItem(arr[i], i);\n      }\n    } else {\n      const keys = Object.keys(source);\n      for (let i = 0, l = keys.length; i < l; i++) {\n        const key = keys[i];\n        renderItem(source[key], key, i);\n      }\n    }\n  }\n}\n\nasync function ssrRenderSuspense(push, { default: renderContent }) {\n  if (renderContent) {\n    renderContent();\n  } else {\n    push(`<!---->`);\n  }\n}\n\nfunction ssrGetDirectiveProps(instance, dir, value, arg, modifiers = {}) {\n  if (typeof dir !== \"function\" && dir.getSSRProps) {\n    return dir.getSSRProps(\n      {\n        dir,\n        instance: ssrUtils.getComponentPublicInstance(instance.$),\n        value,\n        oldValue: void 0,\n        arg,\n        modifiers\n      },\n      null\n    ) || {};\n  }\n  return {};\n}\n\nconst ssrLooseEqual = looseEqual;\nfunction ssrLooseContain(arr, value) {\n  return looseIndexOf(arr, value) > -1;\n}\nfunction ssrRenderDynamicModel(type, model, value) {\n  switch (type) {\n    case \"radio\":\n      return looseEqual(model, value) ? \" checked\" : \"\";\n    case \"checkbox\":\n      return (isArray(model) ? ssrLooseContain(model, value) : model) ? \" checked\" : \"\";\n    default:\n      return ssrRenderAttr(\"value\", model);\n  }\n}\nfunction ssrGetDynamicModelProps(existingProps = {}, model) {\n  const { type, value } = existingProps;\n  switch (type) {\n    case \"radio\":\n      return looseEqual(model, value) ? { checked: true } : null;\n    case \"checkbox\":\n      return (isArray(model) ? ssrLooseContain(model, value) : model) ? { checked: true } : null;\n    default:\n      return { value: model };\n  }\n}\n\nfunction ssrCompile(template, instance) {\n  {\n    throw new Error(\n      `On-the-fly template compilation is not supported in the ESM build of @vue/server-renderer. All templates must be pre-compiled into render functions.`\n    );\n  }\n}\n\nconst {\n  createComponentInstance,\n  setCurrentRenderingInstance,\n  setupComponent,\n  renderComponentRoot,\n  normalizeVNode\n} = ssrUtils;\nfunction createBuffer() {\n  let appendable = false;\n  const buffer = [];\n  return {\n    getBuffer() {\n      return buffer;\n    },\n    push(item) {\n      const isStringItem = isString(item);\n      if (appendable && isStringItem) {\n        buffer[buffer.length - 1] += item;\n        return;\n      }\n      buffer.push(item);\n      appendable = isStringItem;\n      if (isPromise(item) || isArray(item) && item.hasAsync) {\n        buffer.hasAsync = true;\n      }\n    }\n  };\n}\nfunction renderComponentVNode(vnode, parentComponent = null, slotScopeId) {\n  const instance = createComponentInstance(vnode, parentComponent, null);\n  const res = setupComponent(\n    instance,\n    true\n    /* isSSR */\n  );\n  const hasAsyncSetup = isPromise(res);\n  const prefetches = instance.sp;\n  if (hasAsyncSetup || prefetches) {\n    let p = hasAsyncSetup ? res : Promise.resolve();\n    if (prefetches) {\n      p = p.then(\n        () => Promise.all(\n          prefetches.map((prefetch) => prefetch.call(instance.proxy))\n        )\n      ).catch(NOOP);\n    }\n    return p.then(() => renderComponentSubTree(instance, slotScopeId));\n  } else {\n    return renderComponentSubTree(instance, slotScopeId);\n  }\n}\nfunction renderComponentSubTree(instance, slotScopeId) {\n  const comp = instance.type;\n  const { getBuffer, push } = createBuffer();\n  if (isFunction(comp)) {\n    let root = renderComponentRoot(instance);\n    if (!comp.props) {\n      for (const key in instance.attrs) {\n        if (key.startsWith(`data-v-`)) {\n          (root.props || (root.props = {}))[key] = ``;\n        }\n      }\n    }\n    renderVNode(push, instance.subTree = root, instance, slotScopeId);\n  } else {\n    if ((!instance.render || instance.render === NOOP) && !instance.ssrRender && !comp.ssrRender && isString(comp.template)) {\n      comp.ssrRender = ssrCompile(comp.template);\n    }\n    for (const e of instance.scope.effects) {\n      if (e.computed) {\n        e.computed._dirty = true;\n        e.computed._cacheable = true;\n      }\n    }\n    const ssrRender = instance.ssrRender || comp.ssrRender;\n    if (ssrRender) {\n      let attrs = instance.inheritAttrs !== false ? instance.attrs : void 0;\n      let hasCloned = false;\n      let cur = instance;\n      while (true) {\n        const scopeId = cur.vnode.scopeId;\n        if (scopeId) {\n          if (!hasCloned) {\n            attrs = { ...attrs };\n            hasCloned = true;\n          }\n          attrs[scopeId] = \"\";\n        }\n        const parent = cur.parent;\n        if (parent && parent.subTree && parent.subTree === cur.vnode) {\n          cur = parent;\n        } else {\n          break;\n        }\n      }\n      if (slotScopeId) {\n        if (!hasCloned) attrs = { ...attrs };\n        const slotScopeIdList = slotScopeId.trim().split(\" \");\n        for (let i = 0; i < slotScopeIdList.length; i++) {\n          attrs[slotScopeIdList[i]] = \"\";\n        }\n      }\n      const prev = setCurrentRenderingInstance(instance);\n      try {\n        ssrRender(\n          instance.proxy,\n          push,\n          instance,\n          attrs,\n          // compiler-optimized bindings\n          instance.props,\n          instance.setupState,\n          instance.data,\n          instance.ctx\n        );\n      } finally {\n        setCurrentRenderingInstance(prev);\n      }\n    } else if (instance.render && instance.render !== NOOP) {\n      renderVNode(\n        push,\n        instance.subTree = renderComponentRoot(instance),\n        instance,\n        slotScopeId\n      );\n    } else {\n      const componentName = comp.name || comp.__file || `<Anonymous>`;\n      warn$2(`Component ${componentName} is missing template or render function.`);\n      push(`<!---->`);\n    }\n  }\n  return getBuffer();\n}\nfunction renderVNode(push, vnode, parentComponent, slotScopeId) {\n  const { type, shapeFlag, children } = vnode;\n  switch (type) {\n    case Text:\n      push(escapeHtml(children));\n      break;\n    case Comment:\n      push(\n        children ? `<!--${escapeHtmlComment(children)}-->` : `<!---->`\n      );\n      break;\n    case Static:\n      push(children);\n      break;\n    case Fragment:\n      if (vnode.slotScopeIds) {\n        slotScopeId = (slotScopeId ? slotScopeId + \" \" : \"\") + vnode.slotScopeIds.join(\" \");\n      }\n      push(`<!--[-->`);\n      renderVNodeChildren(\n        push,\n        children,\n        parentComponent,\n        slotScopeId\n      );\n      push(`<!--]-->`);\n      break;\n    default:\n      if (shapeFlag & 1) {\n        renderElementVNode(push, vnode, parentComponent, slotScopeId);\n      } else if (shapeFlag & 6) {\n        push(renderComponentVNode(vnode, parentComponent, slotScopeId));\n      } else if (shapeFlag & 64) {\n        renderTeleportVNode(push, vnode, parentComponent, slotScopeId);\n      } else if (shapeFlag & 128) {\n        renderVNode(push, vnode.ssContent, parentComponent, slotScopeId);\n      } else {\n        warn$2(\n          \"[@vue/server-renderer] Invalid VNode type:\",\n          type,\n          `(${typeof type})`\n        );\n      }\n  }\n}\nfunction renderVNodeChildren(push, children, parentComponent, slotScopeId) {\n  for (let i = 0; i < children.length; i++) {\n    renderVNode(push, normalizeVNode(children[i]), parentComponent, slotScopeId);\n  }\n}\nfunction renderElementVNode(push, vnode, parentComponent, slotScopeId) {\n  const tag = vnode.type;\n  let { props, children, shapeFlag, scopeId, dirs } = vnode;\n  let openTag = `<${tag}`;\n  if (dirs) {\n    props = applySSRDirectives(vnode, props, dirs);\n  }\n  if (props) {\n    openTag += ssrRenderAttrs(props, tag);\n  }\n  if (scopeId) {\n    openTag += ` ${scopeId}`;\n  }\n  let curParent = parentComponent;\n  let curVnode = vnode;\n  while (curParent && curVnode === curParent.subTree) {\n    curVnode = curParent.vnode;\n    if (curVnode.scopeId) {\n      openTag += ` ${curVnode.scopeId}`;\n    }\n    curParent = curParent.parent;\n  }\n  if (slotScopeId) {\n    openTag += ` ${slotScopeId}`;\n  }\n  push(openTag + `>`);\n  if (!isVoidTag(tag)) {\n    let hasChildrenOverride = false;\n    if (props) {\n      if (props.innerHTML) {\n        hasChildrenOverride = true;\n        push(props.innerHTML);\n      } else if (props.textContent) {\n        hasChildrenOverride = true;\n        push(escapeHtml(props.textContent));\n      } else if (tag === \"textarea\" && props.value) {\n        hasChildrenOverride = true;\n        push(escapeHtml(props.value));\n      }\n    }\n    if (!hasChildrenOverride) {\n      if (shapeFlag & 8) {\n        push(escapeHtml(children));\n      } else if (shapeFlag & 16) {\n        renderVNodeChildren(\n          push,\n          children,\n          parentComponent,\n          slotScopeId\n        );\n      }\n    }\n    push(`</${tag}>`);\n  }\n}\nfunction applySSRDirectives(vnode, rawProps, dirs) {\n  const toMerge = [];\n  for (let i = 0; i < dirs.length; i++) {\n    const binding = dirs[i];\n    const {\n      dir: { getSSRProps }\n    } = binding;\n    if (getSSRProps) {\n      const props = getSSRProps(binding, vnode);\n      if (props) toMerge.push(props);\n    }\n  }\n  return mergeProps(rawProps || {}, ...toMerge);\n}\nfunction renderTeleportVNode(push, vnode, parentComponent, slotScopeId) {\n  const target = vnode.props && vnode.props.to;\n  const disabled = vnode.props && vnode.props.disabled;\n  if (!target) {\n    if (!disabled) {\n      warn$2(`[@vue/server-renderer] Teleport is missing target prop.`);\n    }\n    return [];\n  }\n  if (!isString(target)) {\n    warn$2(\n      `[@vue/server-renderer] Teleport target must be a query selector string.`\n    );\n    return [];\n  }\n  ssrRenderTeleport(\n    push,\n    (push2) => {\n      renderVNodeChildren(\n        push2,\n        vnode.children,\n        parentComponent,\n        slotScopeId\n      );\n    },\n    target,\n    disabled || disabled === \"\",\n    parentComponent\n  );\n}\n\nconst { isVNode: isVNode$1 } = ssrUtils;\nfunction nestedUnrollBuffer(buffer, parentRet, startIndex) {\n  if (!buffer.hasAsync) {\n    return parentRet + unrollBufferSync$1(buffer);\n  }\n  let ret = parentRet;\n  for (let i = startIndex; i < buffer.length; i += 1) {\n    const item = buffer[i];\n    if (isString(item)) {\n      ret += item;\n      continue;\n    }\n    if (isPromise(item)) {\n      return item.then((nestedItem) => {\n        buffer[i] = nestedItem;\n        return nestedUnrollBuffer(buffer, ret, i);\n      });\n    }\n    const result = nestedUnrollBuffer(item, ret, 0);\n    if (isPromise(result)) {\n      return result.then((nestedItem) => {\n        buffer[i] = nestedItem;\n        return nestedUnrollBuffer(buffer, \"\", i);\n      });\n    }\n    ret = result;\n  }\n  return ret;\n}\nfunction unrollBuffer$1(buffer) {\n  return nestedUnrollBuffer(buffer, \"\", 0);\n}\nfunction unrollBufferSync$1(buffer) {\n  let ret = \"\";\n  for (let i = 0; i < buffer.length; i++) {\n    let item = buffer[i];\n    if (isString(item)) {\n      ret += item;\n    } else {\n      ret += unrollBufferSync$1(item);\n    }\n  }\n  return ret;\n}\nasync function renderToString(input, context = {}) {\n  if (isVNode$1(input)) {\n    return renderToString(createApp({ render: () => input }), context);\n  }\n  const vnode = createVNode(input._component, input._props);\n  vnode.appContext = input._context;\n  input.provide(ssrContextKey, context);\n  const buffer = await renderComponentVNode(vnode);\n  const result = await unrollBuffer$1(buffer);\n  await resolveTeleports(context);\n  if (context.__watcherHandles) {\n    for (const unwatch of context.__watcherHandles) {\n      unwatch();\n    }\n  }\n  return result;\n}\nasync function resolveTeleports(context) {\n  if (context.__teleportBuffers) {\n    context.teleports = context.teleports || {};\n    for (const key in context.__teleportBuffers) {\n      context.teleports[key] = await unrollBuffer$1(\n        await Promise.all([context.__teleportBuffers[key]])\n      );\n    }\n  }\n}\n\nconst { isVNode } = ssrUtils;\nasync function unrollBuffer(buffer, stream) {\n  if (buffer.hasAsync) {\n    for (let i = 0; i < buffer.length; i++) {\n      let item = buffer[i];\n      if (isPromise(item)) {\n        item = await item;\n      }\n      if (isString(item)) {\n        stream.push(item);\n      } else {\n        await unrollBuffer(item, stream);\n      }\n    }\n  } else {\n    unrollBufferSync(buffer, stream);\n  }\n}\nfunction unrollBufferSync(buffer, stream) {\n  for (let i = 0; i < buffer.length; i++) {\n    let item = buffer[i];\n    if (isString(item)) {\n      stream.push(item);\n    } else {\n      unrollBufferSync(item, stream);\n    }\n  }\n}\nfunction renderToSimpleStream(input, context, stream) {\n  if (isVNode(input)) {\n    return renderToSimpleStream(\n      createApp({ render: () => input }),\n      context,\n      stream\n    );\n  }\n  const vnode = createVNode(input._component, input._props);\n  vnode.appContext = input._context;\n  input.provide(ssrContextKey, context);\n  Promise.resolve(renderComponentVNode(vnode)).then((buffer) => unrollBuffer(buffer, stream)).then(() => resolveTeleports(context)).then(() => {\n    if (context.__watcherHandles) {\n      for (const unwatch of context.__watcherHandles) {\n        unwatch();\n      }\n    }\n  }).then(() => stream.push(null)).catch((error) => {\n    stream.destroy(error);\n  });\n  return stream;\n}\nfunction renderToStream(input, context = {}) {\n  console.warn(\n    `[@vue/server-renderer] renderToStream is deprecated - use renderToNodeStream instead.`\n  );\n  return renderToNodeStream(input, context);\n}\nfunction renderToNodeStream(input, context = {}) {\n  {\n    throw new Error(\n      `ESM build of renderToStream() does not support renderToNodeStream(). Use pipeToNodeWritable() with an existing Node.js Writable stream instance instead.`\n    );\n  }\n}\nfunction pipeToNodeWritable(input, context = {}, writable) {\n  renderToSimpleStream(input, context, {\n    push(content) {\n      if (content != null) {\n        writable.write(content);\n      } else {\n        writable.end();\n      }\n    },\n    destroy(err) {\n      writable.destroy(err);\n    }\n  });\n}\nfunction renderToWebStream(input, context = {}) {\n  if (typeof ReadableStream !== \"function\") {\n    throw new Error(\n      `ReadableStream constructor is not available in the global scope. If the target environment does support web streams, consider using pipeToWebWritable() with an existing WritableStream instance instead.`\n    );\n  }\n  const encoder = new TextEncoder();\n  let cancelled = false;\n  return new ReadableStream({\n    start(controller) {\n      renderToSimpleStream(input, context, {\n        push(content) {\n          if (cancelled) return;\n          if (content != null) {\n            controller.enqueue(encoder.encode(content));\n          } else {\n            controller.close();\n          }\n        },\n        destroy(err) {\n          controller.error(err);\n        }\n      });\n    },\n    cancel() {\n      cancelled = true;\n    }\n  });\n}\nfunction pipeToWebWritable(input, context = {}, writable) {\n  const writer = writable.getWriter();\n  const encoder = new TextEncoder();\n  let hasReady = false;\n  try {\n    hasReady = isPromise(writer.ready);\n  } catch (e) {\n  }\n  renderToSimpleStream(input, context, {\n    async push(content) {\n      if (hasReady) {\n        await writer.ready;\n      }\n      if (content != null) {\n        return writer.write(encoder.encode(content));\n      } else {\n        return writer.close();\n      }\n    },\n    destroy(err) {\n      console.log(err);\n      writer.close();\n    }\n  });\n}\n\ninitDirectivesForSSR();\n\nexport { pipeToNodeWritable, pipeToWebWritable, renderToNodeStream, renderToSimpleStream, renderToStream, renderToString, renderToWebStream, ssrGetDirectiveProps, ssrGetDynamicModelProps, ssrInterpolate, ssrLooseContain, ssrLooseEqual, ssrRenderAttr, ssrRenderAttrs, ssrRenderClass, ssrRenderComponent, ssrRenderDynamicAttr, ssrRenderDynamicModel, ssrRenderList, ssrRenderSlot, ssrRenderSlotInner, ssrRenderStyle, ssrRenderSuspense, ssrRenderTeleport, renderVNode as ssrRenderVNode };\n", "/**\n * vue-meta v3.0.0-alpha.2\n * (c) 2021\n * - Pim (@pimlie)\n * - All the amazing contributors\n * @license MIT\n */\n\nimport { markRaw, h, getCurrentInstance, isProxy, watch, inject, defineComponent, reactive, onUnmounted, Teleport } from 'vue';\n\nconst resolveOption = predicament => (options, contexts) => {\r\n    let resolvedIndex = -1;\r\n    contexts.reduce((acc, context, index) => {\r\n        const retval = predicament(acc, context);\r\n        if (retval !== acc) {\r\n            resolvedIndex = index;\r\n            return retval;\r\n        }\r\n        return acc;\r\n    }, undefined);\r\n    if (resolvedIndex > -1) {\r\n        return options[resolvedIndex];\r\n    }\r\n};\n\nfunction setup(context) {\r\n    let depth = 0;\r\n    if (context.vm) {\r\n        let { vm } = context;\r\n        do {\r\n            if (vm.parent) {\r\n                depth++;\r\n                vm = vm.parent;\r\n            }\r\n        } while (vm && vm.parent && vm !== vm.root);\r\n    }\r\n    context.depth = depth;\r\n}\r\nconst resolve = resolveOption((acc, context) => {\r\n    const { depth } = context;\r\n    if (!acc || depth > acc) {\r\n        return acc;\r\n    }\r\n});\n\nvar deepest = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  setup: setup,\n  resolve: resolve\n});\n\nconst defaultConfig = {\r\n    body: {\r\n        tag: 'script',\r\n        to: 'body'\r\n    },\r\n    base: {\r\n        valueAttribute: 'href'\r\n    },\r\n    charset: {\r\n        tag: 'meta',\r\n        nameless: true,\r\n        valueAttribute: 'charset'\r\n    },\r\n    description: {\r\n        tag: 'meta'\r\n    },\r\n    og: {\r\n        group: true,\r\n        namespacedAttribute: true,\r\n        tag: 'meta',\r\n        keyAttribute: 'property'\r\n    },\r\n    twitter: {\r\n        group: true,\r\n        namespacedAttribute: true,\r\n        tag: 'meta'\r\n    },\r\n    htmlAttrs: {\r\n        attributesFor: 'html'\r\n    },\r\n    headAttrs: {\r\n        attributesFor: 'head'\r\n    },\r\n    bodyAttrs: {\r\n        attributesFor: 'body'\r\n    }\r\n};\n\n/*\r\n * This is a fixed config for real HTML tags\r\n */\r\nconst tags = {\r\n    title: {\r\n        attributes: false\r\n    },\r\n    base: {\r\n        contentAsAttribute: true,\r\n        attributes: ['href', 'target']\r\n    },\r\n    meta: {\r\n        contentAsAttribute: true,\r\n        keyAttribute: 'name',\r\n        attributes: ['content', 'name', 'http-equiv', 'charset']\r\n    },\r\n    link: {\r\n        contentAsAttribute: true,\r\n        attributes: [\r\n            'href',\r\n            'crossorigin',\r\n            'rel',\r\n            'media',\r\n            'integrity',\r\n            'hreflang',\r\n            'type',\r\n            'referrerpolicy',\r\n            'sizes',\r\n            'imagesrcset',\r\n            'imagesizes',\r\n            'as',\r\n            'color'\r\n        ]\r\n    },\r\n    style: {\r\n        attributes: ['media']\r\n    },\r\n    script: {\r\n        attributes: [\r\n            'src',\r\n            'type',\r\n            'nomodule',\r\n            'async',\r\n            'defer',\r\n            'crossorigin',\r\n            'integrity',\r\n            'referrerpolicy'\r\n        ]\r\n    },\r\n    noscript: {\r\n        attributes: false\r\n    }\r\n};\n\nfunction getTagConfigItem(tagOrName, key) {\r\n    for (const name of tagOrName) {\r\n        const tag = tags[name];\r\n        if (name && tag) {\r\n            return tag[key];\r\n        }\r\n    }\r\n}\n\n/**\r\n * Make a map and return a function for checking if a key\r\n * is in that map.\r\n * IMPORTANT: all calls of this function must be prefixed with\r\n * \\/\\*#\\_\\_PURE\\_\\_\\*\\/\r\n * So that rollup can tree-shake them if necessary.\r\n */\r\n(process.env.NODE_ENV !== 'production')\r\n    ? Object.freeze({})\r\n    : {};\r\n(process.env.NODE_ENV !== 'production') ? Object.freeze([]) : [];\r\nconst isArray = Array.isArray;\r\nconst isFunction = (val) => typeof val === 'function';\r\nconst isString = (val) => typeof val === 'string';\r\nconst isObject = (val) => val !== null && typeof val === 'object';\r\nconst objectToString = Object.prototype.toString;\r\nconst toTypeString = (value) => objectToString.call(value);\r\nconst isPlainObject = (val) => toTypeString(val) === '[object Object]';\n\n// https://github.com/microsoft/TypeScript/issues/1863\r\nconst IS_PROXY = Symbol('kIsProxy');\r\nconst PROXY_SOURCES = Symbol('kProxySources');\r\nconst PROXY_TARGET = Symbol('kProxyTarget');\r\nconst RESOLVE_CONTEXT = Symbol('kResolveContext');\n\n// See: https://github.com/vuejs/vue-next/blob/08b4e8815da4e8911058ccbab986bea6365c3352/packages/compiler-ssr/src/transforms/ssrTransformComponent.ts\r\nfunction clone(v) {\r\n    if (isArray(v)) {\r\n        return v.map(clone);\r\n    }\r\n    if (isObject(v)) {\r\n        const res = {};\r\n        for (const key in v) {\r\n            // never clone the context\r\n            if (key === 'context') {\r\n                res[key] = v[key];\r\n            }\r\n            else {\r\n                res[key] = clone(v[key]);\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n    return v;\r\n}\n\nconst pluck = (collection, key, callback) => {\r\n    const plucked = [];\r\n    for (const row of collection) {\r\n        if (key in row) {\r\n            plucked.push(row[key]);\r\n            if (callback) {\r\n                callback(row);\r\n            }\r\n        }\r\n    }\r\n    return plucked;\r\n};\n\nconst allKeys = (source, ...sources) => {\r\n    const keys = source ? Object.keys(source) : [];\r\n    if (sources) {\r\n        for (const source of sources) {\r\n            if (!source || !isObject(source)) {\r\n                continue;\r\n            }\r\n            for (const key in source) {\r\n                if (!keys.includes(key)) {\r\n                    keys.push(key);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    // TODO: add check for consistent types for each key (dev only)\r\n    return keys;\r\n};\r\nconst recompute = (context, sources, target, path = []) => {\r\n    if (!path.length) {\r\n        if (!target) {\r\n            target = context.active;\r\n        }\r\n        if (!sources) {\r\n            sources = context.sources;\r\n        }\r\n    }\r\n    if (!target || !sources) {\r\n        return;\r\n    }\r\n    const keys = allKeys(...sources);\r\n    // Clean up properties that dont exists anymore\r\n    const targetKeys = Object.keys(target);\r\n    for (const key of targetKeys) {\r\n        if (!keys.includes(key)) {\r\n            delete target[key];\r\n        }\r\n    }\r\n    for (const key of keys) {\r\n        // This assumes consistent types usages for keys across sources\r\n        if (isPlainObject(sources[0][key])) {\r\n            if (!target[key]) {\r\n                target[key] = {};\r\n            }\r\n            const keySources = [];\r\n            for (const source of sources) {\r\n                if (key in source) {\r\n                    keySources.push(source[key]);\r\n                }\r\n            }\r\n            recompute(context, keySources, target[key], [...path, key]);\r\n            continue;\r\n        }\r\n        // Ensure the target is an array if source is an array and target is empty\r\n        if (!target[key] && isArray(sources[0][key])) {\r\n            target[key] = [];\r\n        }\r\n        const keyContexts = [];\r\n        const keySources = pluck(sources, key, source => keyContexts.push(source[RESOLVE_CONTEXT]));\r\n        let resolved = context.resolve(keySources, keyContexts, target[key], key, path);\r\n        if (isPlainObject(resolved)) {\r\n            resolved = clone(resolved);\r\n        }\r\n        // console.log('RESOLVED', key, resolved, 'was', target[key])\r\n        target[key] = resolved;\r\n    }\r\n};\n\nconst createProxy = (context, target, resolveContext, pathSegments = []) => {\r\n    const handler = createHandler(context, resolveContext, pathSegments);\r\n    const proxy = markRaw(new Proxy(target, handler));\r\n    if (!pathSegments.length && context.sources) {\r\n        context.sources.push(proxy);\r\n    }\r\n    return proxy;\r\n};\r\nconst createHandler = (context, resolveContext, pathSegments = []) => ({\r\n    get: (target, key, receiver) => {\r\n        if (key === IS_PROXY) {\r\n            return true;\r\n        }\r\n        if (key === PROXY_SOURCES) {\r\n            return context.sources;\r\n        }\r\n        if (key === PROXY_TARGET) {\r\n            return target;\r\n        }\r\n        if (key === RESOLVE_CONTEXT) {\r\n            return resolveContext;\r\n        }\r\n        let value = Reflect.get(target, key, receiver);\r\n        if (!isObject(value)) {\r\n            return value;\r\n        }\r\n        if (!value[IS_PROXY]) {\r\n            const keyPath = [...pathSegments, key];\r\n            value = createProxy(context, value, resolveContext, keyPath);\r\n            target[key] = value;\r\n        }\r\n        return value;\r\n    },\r\n    set: (target, key, value) => {\r\n        const success = Reflect.set(target, key, value);\r\n        // console.warn(success, 'PROXY SET\\nkey:', key, '\\npath:', pathSegments, '\\ntarget:', isArray(target), target, '\\ncontext:\\n', context)\r\n        if (success) {\r\n            const isArrayItem = isArray(target);\r\n            let hasArrayParent = false;\r\n            let { sources: proxies, active } = context;\r\n            let activeSegmentKey;\r\n            let index = 0;\r\n            for (const segment of pathSegments) {\r\n                proxies = pluck(proxies, segment);\r\n                if (isArrayItem && index === pathSegments.length - 1) {\r\n                    activeSegmentKey = segment;\r\n                    break;\r\n                }\r\n                if (isArray(active)) {\r\n                    hasArrayParent = true;\r\n                }\r\n                active = active[segment];\r\n                index++;\r\n            }\r\n            if (hasArrayParent) {\r\n                // TODO: fix that we dont have to recompute the full merged object\r\n                // we should only have to recompute the branch that has changed\r\n                // but there is an issue here with supporting both arrays of strings\r\n                // as collections (parent vs parent of parent we need to trigger the\r\n                // update from)\r\n                recompute(context);\r\n                return success;\r\n            }\r\n            let keyContexts = [];\r\n            let keySources;\r\n            if (isArrayItem) {\r\n                keySources = proxies;\r\n                keyContexts = proxies.map(proxy => proxy[RESOLVE_CONTEXT]);\r\n            }\r\n            else {\r\n                keySources = pluck(proxies, key, proxy => keyContexts.push(proxy[RESOLVE_CONTEXT]));\r\n            }\r\n            let resolved = context.resolve(keySources, keyContexts, active, key, pathSegments);\r\n            // Ensure to clone if value is an object, cause sources is an array of\r\n            // the sourceProxies not the sources so we could trigger an endless loop when\r\n            // updating a prop on an obj as the prop on the active object refers to\r\n            // a prop on a proxy\r\n            if (isPlainObject(resolved)) {\r\n                resolved = clone(resolved);\r\n            }\r\n            //      console.log('SET VALUE', isArrayItem, key, '\\nresolved:\\n', resolved, '\\nsources:\\n', context.sources, '\\nactive:\\n', active, Object.keys(active))\r\n            if (isArrayItem && activeSegmentKey) {\r\n                active[activeSegmentKey] = resolved;\r\n            }\r\n            else {\r\n                active[key] = resolved;\r\n            }\r\n        }\r\n        //    console.log('CONTEXT.ACTIVE', context.active, '\\nparent:\\n', target)\r\n        return success;\r\n    },\r\n    deleteProperty: (target, key) => {\r\n        const success = Reflect.deleteProperty(target, key);\r\n        //    console.warn('PROXY DELETE\\nkey:', key, '\\npath:', pathSegments, '\\nparent:', isArray(target), target)\r\n        if (success) {\r\n            const isArrayItem = isArray(target);\r\n            let activeSegmentKey;\r\n            let proxies = context.sources;\r\n            let active = context.active;\r\n            let index = 0;\r\n            for (const segment of pathSegments) {\r\n                proxies = proxies.map(proxy => proxy[segment]);\r\n                if (isArrayItem && index === pathSegments.length - 1) {\r\n                    activeSegmentKey = segment;\r\n                    break;\r\n                }\r\n                active = active[segment];\r\n                index++;\r\n            }\r\n            // Check if the key still exists in one of the sourceProxies,\r\n            // if so resolve the new value, if not remove the key\r\n            if (proxies.some(proxy => (key in proxy))) {\r\n                let keyContexts = [];\r\n                let keySources;\r\n                if (isArrayItem) {\r\n                    keySources = proxies;\r\n                    keyContexts = proxies.map(proxy => proxy[RESOLVE_CONTEXT]);\r\n                }\r\n                else {\r\n                    keySources = pluck(proxies, key, proxy => keyContexts.push(proxy[RESOLVE_CONTEXT]));\r\n                }\r\n                let resolved = context.resolve(keySources, keyContexts, active, key, pathSegments);\r\n                if (isPlainObject(resolved)) {\r\n                    resolved = clone(resolved);\r\n                }\r\n                //        console.log('SET VALUE', resolved)\r\n                if (isArrayItem && activeSegmentKey) {\r\n                    active[activeSegmentKey] = resolved;\r\n                }\r\n                else {\r\n                    active[key] = resolved;\r\n                }\r\n            }\r\n            else {\r\n                delete active[key];\r\n            }\r\n        }\r\n        return success;\r\n    }\r\n});\n\nconst createMergedObject = (resolve, active = {}) => {\r\n    const sources = [];\r\n    if (!active) {\r\n        active = {};\r\n    }\r\n    const context = {\r\n        active,\r\n        resolve,\r\n        sources\r\n    };\r\n    const compute = () => recompute(context);\r\n    return {\r\n        context,\r\n        compute,\r\n        addSource: (source, resolveContext, recompute = false) => {\r\n            const proxy = createProxy(context, source, resolveContext || {});\r\n            if (recompute) {\r\n                compute();\r\n            }\r\n            return proxy;\r\n        },\r\n        delSource: (sourceOrProxy, recompute = true) => {\r\n            const index = sources.findIndex(src => src === sourceOrProxy || src[PROXY_TARGET] === sourceOrProxy);\r\n            if (index > -1) {\r\n                sources.splice(index, 1);\r\n                if (recompute) {\r\n                    compute();\r\n                }\r\n                return true;\r\n            }\r\n            return false;\r\n        }\r\n    };\r\n};\n\nfunction renderMeta(context, key, data, config) {\r\n    // console.info('renderMeta', key, data, config)\r\n    if ('attributesFor' in config) {\r\n        return renderAttributes(context, key, data, config);\r\n    }\r\n    if ('group' in config) {\r\n        return renderGroup(context, key, data, config);\r\n    }\r\n    return renderTag(context, key, data, config);\r\n}\r\nfunction renderGroup(context, key, data, config) {\r\n    // console.info('renderGroup', key, data, config)\r\n    if (isArray(data)) {\r\n        if ((process.env.NODE_ENV !== 'production')) {\r\n            // eslint-disable-next-line no-console\r\n            console.warn('Specifying an array for group properties isnt supported');\r\n        }\r\n        // config.attributes = getConfigKey([key, config.tag], 'attributes', config)\r\n        return [];\r\n    }\r\n    return Object.keys(data)\r\n        .map((childKey) => {\r\n        const groupConfig = {\r\n            group: key,\r\n            data\r\n        };\r\n        if (config.namespaced) {\r\n            groupConfig.tagNamespace = config.namespaced === true ? key : config.namespaced;\r\n        }\r\n        else if (config.namespacedAttribute) {\r\n            const namespace = config.namespacedAttribute === true ? key : config.namespacedAttribute;\r\n            groupConfig.fullName = `${namespace}:${childKey}`;\r\n            groupConfig.slotName = `${namespace}(${childKey})`;\r\n        }\r\n        return renderTag(context, key, data[childKey], config, groupConfig);\r\n    })\r\n        .flat();\r\n}\r\nfunction renderTag(context, key, data, config = {}, groupConfig) {\r\n    // console.info('renderTag', key, data, config, groupConfig)\r\n    const contentAttributes = ['content', 'json', 'rawContent'];\r\n    const getTagConfig = (key) => getTagConfigItem([tag, config.tag], key);\r\n    if (isArray(data)) {\r\n        return data\r\n            .map((child) => {\r\n            return renderTag(context, key, child, config, groupConfig);\r\n        })\r\n            .flat();\r\n    }\r\n    const { tag = config.tag || key } = data;\r\n    let content = '';\r\n    let hasChilds = false;\r\n    let isRaw = false;\r\n    if (isString(data)) {\r\n        content = data;\r\n    }\r\n    else if (data.children && isArray(data.children)) {\r\n        hasChilds = true;\r\n        content = data.children.map((child) => {\r\n            const data = renderTag(context, key, child, config, groupConfig);\r\n            if (isArray(data)) {\r\n                return data.map(({ vnode }) => vnode);\r\n            }\r\n            return data.vnode;\r\n        });\r\n    }\r\n    else {\r\n        let i = 0;\r\n        for (const contentAttribute of contentAttributes) {\r\n            if (!content && data[contentAttribute]) {\r\n                if (i === 1) {\r\n                    content = JSON.stringify(data[contentAttribute]);\r\n                }\r\n                else {\r\n                    content = data[contentAttribute];\r\n                }\r\n                isRaw = i > 1;\r\n                break;\r\n            }\r\n            i++;\r\n        }\r\n    }\r\n    const fullName = (groupConfig && groupConfig.fullName) || key;\r\n    const slotName = (groupConfig && groupConfig.slotName) || key;\r\n    let { attrs: attributes } = data;\r\n    if (!attributes && typeof data === 'object') {\r\n        attributes = { ...data };\r\n        delete attributes.tag;\r\n        delete attributes.children;\r\n        delete attributes.to;\r\n        // cleanup all content attributes\r\n        for (const attr of contentAttributes) {\r\n            delete attributes[attr];\r\n        }\r\n    }\r\n    else if (!attributes) {\r\n        attributes = {};\r\n    }\r\n    if (hasChilds) {\r\n        content = getSlotContent(context, slotName, content, data);\r\n    }\r\n    else {\r\n        const contentAsAttribute = !!getTagConfig('contentAsAttribute');\r\n        let { valueAttribute } = config;\r\n        if (!valueAttribute && contentAsAttribute) {\r\n            const [tagAttribute] = getTagConfig('attributes');\r\n            valueAttribute = isString(contentAsAttribute) ? contentAsAttribute : tagAttribute;\r\n        }\r\n        if (!valueAttribute) {\r\n            content = getSlotContent(context, slotName, content, data);\r\n        }\r\n        else {\r\n            const { nameless, keyAttribute } = config;\r\n            if (!nameless) {\r\n                if (keyAttribute) {\r\n                    attributes[keyAttribute] = fullName;\r\n                }\r\n            }\r\n            attributes[valueAttribute] = getSlotContent(context, slotName, attributes[valueAttribute] || content, groupConfig);\r\n            content = '';\r\n        }\r\n    }\r\n    const finalTag = groupConfig && groupConfig.tagNamespace\r\n        ? `${groupConfig.tagNamespace}:${tag}`\r\n        : tag;\r\n    // console.info('FINAL TAG', finalTag)\r\n    // console.log('      ATTRIBUTES', attributes)\r\n    // console.log('      CONTENT', content)\r\n    // // console.log(data, attributes, config)\r\n    if (isRaw && content) {\r\n        attributes.innerHTML = content;\r\n    }\r\n    // Ignore empty string content\r\n    const vnode = h(finalTag, attributes, content || undefined);\r\n    return {\r\n        to: data.to,\r\n        vnode\r\n    };\r\n}\r\nfunction renderAttributes(context, key, data, config) {\r\n    // console.info('renderAttributes', key, data, config)\r\n    const { attributesFor } = config;\r\n    if (!attributesFor) {\r\n        return;\r\n    }\r\n    {\r\n        // render attributes in a placeholder vnode so Vue\r\n        // will render the string for us\r\n        return {\r\n            to: '',\r\n            vnode: h(`ssr-${attributesFor}`, data)\r\n        };\r\n    }\r\n}\r\nfunction getSlotContent({ metainfo, slots }, slotName, content, groupConfig) {\r\n    const slot = slots && slots[slotName];\r\n    if (!slot || !isFunction(slot)) {\r\n        return content;\r\n    }\r\n    const slotScopeProps = {\r\n        content,\r\n        metainfo\r\n    };\r\n    if (groupConfig && groupConfig.group) {\r\n        const { group, data } = groupConfig;\r\n        slotScopeProps[group] = data;\r\n    }\r\n    const slotContent = slot(slotScopeProps);\r\n    if (slotContent && slotContent.length) {\r\n        const { children } = slotContent[0];\r\n        return children ? children.toString() : '';\r\n    }\r\n    return content;\r\n}\n\nconst hasSymbol = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';\r\nconst PolySymbol = (name) => \r\n// vm = vue meta\r\nhasSymbol\r\n    ? Symbol((process.env.NODE_ENV !== 'production') ? '[vue-meta]: ' + name : name)\r\n    : ((process.env.NODE_ENV !== 'production') ? '[vue-meta]: ' : '_vm_') + name;\r\nconst metaActiveKey = /*#__PURE__*/ PolySymbol((process.env.NODE_ENV !== 'production') ? 'meta_active' : 'ma');\n\n/**\r\n * Apply the differences between newSource & oldSource to target\r\n */\r\nfunction applyDifference(target, newSource, oldSource) {\r\n    for (const key in newSource) {\r\n        if (!(key in oldSource)) {\r\n            target[key] = newSource[key];\r\n            continue;\r\n        }\r\n        // We dont care about nested objects here , these changes\r\n        // should already have been tracked by the MergeProxy\r\n        if (isObject(target[key])) {\r\n            continue;\r\n        }\r\n        if (newSource[key] !== oldSource[key]) {\r\n            target[key] = newSource[key];\r\n        }\r\n    }\r\n    for (const key in oldSource) {\r\n        if (!(key in newSource)) {\r\n            delete target[key];\r\n        }\r\n    }\r\n}\n\nfunction getCurrentManager(vm) {\r\n    if (!vm) {\r\n        vm = getCurrentInstance() || undefined;\r\n    }\r\n    if (!vm) {\r\n        return undefined;\r\n    }\r\n    return vm.appContext.config.globalProperties.$metaManager;\r\n}\r\nfunction useMeta(source, manager) {\r\n    const vm = getCurrentInstance() || undefined;\r\n    if (!manager && vm) {\r\n        manager = getCurrentManager(vm);\r\n    }\r\n    if (!manager) {\r\n        throw new Error('No manager or current instance');\r\n    }\r\n    if (isProxy(source)) {\r\n        watch(source, (newSource, oldSource) => {\r\n            // We only care about first level props, second+ level will already be changed by the merge proxy\r\n            applyDifference(metaProxy.meta, newSource, oldSource);\r\n        });\r\n        source = source.value;\r\n    }\r\n    const metaProxy = manager.addMeta(source, vm);\r\n    return metaProxy;\r\n}\r\nfunction useActiveMeta() {\r\n    return inject(metaActiveKey);\r\n}\n\nconst MetainfoImpl = defineComponent({\r\n    name: 'Metainfo',\r\n    inheritAttrs: false,\r\n    setup(_, { slots }) {\r\n        return () => {\r\n            const manager = getCurrentManager();\r\n            if (!manager) {\r\n                return;\r\n            }\r\n            return manager.render({ slots });\r\n        };\r\n    }\r\n});\r\nconst Metainfo = MetainfoImpl;\n\nconst ssrAttribute = 'data-vm-ssr';\r\nconst active = reactive({});\r\nfunction addVnode(teleports, to, vnodes) {\r\n    const nodes = (isArray(vnodes) ? vnodes : [vnodes]);\r\n    if (!to.endsWith('Attrs')) {\r\n        nodes.forEach((vnode) => {\r\n            if (!vnode.props) {\r\n                vnode.props = {};\r\n            }\r\n            vnode.props[ssrAttribute] = true;\r\n        });\r\n    }\r\n    if (!teleports[to]) {\r\n        teleports[to] = [];\r\n    }\r\n    teleports[to].push(...nodes);\r\n}\r\nconst createMetaManager = (config, resolver) => MetaManager.create(config, resolver);\r\nclass MetaManager {\r\n    constructor(config, target, resolver) {\r\n        this.ssrCleanedUp = false;\r\n        this.config = config;\r\n        this.target = target;\r\n        if (resolver && 'setup' in resolver && isFunction(resolver.setup)) {\r\n            this.resolver = resolver;\r\n        }\r\n    }\r\n    install(app) {\r\n        app.component('Metainfo', Metainfo);\r\n        app.config.globalProperties.$metaManager = this;\r\n        app.provide(metaActiveKey, active);\r\n    }\r\n    addMeta(metadata, vm) {\r\n        if (!vm) {\r\n            vm = getCurrentInstance() || undefined;\r\n        }\r\n        const metaGuards = ({\r\n            removed: []\r\n        });\r\n        const resolveContext = { vm };\r\n        if (this.resolver) {\r\n            this.resolver.setup(resolveContext);\r\n        }\r\n        // TODO: optimize initial compute (once)\r\n        const meta = this.target.addSource(metadata, resolveContext, true);\r\n        const onRemoved = (removeGuard) => metaGuards.removed.push(removeGuard);\r\n        const unmount = (ignoreGuards) => this.unmount(!!ignoreGuards, meta, metaGuards, vm);\r\n        if (vm) {\r\n            onUnmounted(unmount);\r\n        }\r\n        return {\r\n            meta,\r\n            onRemoved,\r\n            unmount\r\n        };\r\n    }\r\n    unmount(ignoreGuards, meta, metaGuards, vm) {\r\n        if (vm) {\r\n            const { $el } = vm.proxy;\r\n            // Wait for element to be removed from DOM\r\n            if ($el && $el.offsetParent) {\r\n                let observer = new MutationObserver((records) => {\r\n                    for (const { removedNodes } of records) {\r\n                        if (!removedNodes) {\r\n                            continue;\r\n                        }\r\n                        removedNodes.forEach((el) => {\r\n                            if (el === $el && observer) {\r\n                                observer.disconnect();\r\n                                observer = undefined;\r\n                                this.reallyUnmount(ignoreGuards, meta, metaGuards);\r\n                            }\r\n                        });\r\n                    }\r\n                });\r\n                observer.observe($el.parentNode, { childList: true });\r\n                return;\r\n            }\r\n        }\r\n        this.reallyUnmount(ignoreGuards, meta, metaGuards);\r\n    }\r\n    async reallyUnmount(ignoreGuards, meta, metaGuards) {\r\n        this.target.delSource(meta);\r\n        if (!ignoreGuards && metaGuards) {\r\n            await Promise.all(metaGuards.removed.map(removeGuard => removeGuard()));\r\n        }\r\n    }\r\n    render({ slots } = {}) {\r\n        const teleports = {};\r\n        for (const key in active) {\r\n            const config = this.config[key] || {};\r\n            let renderedNodes = renderMeta({ metainfo: active, slots }, key, active[key], config);\r\n            if (!renderedNodes) {\r\n                continue;\r\n            }\r\n            if (!isArray(renderedNodes)) {\r\n                renderedNodes = [renderedNodes];\r\n            }\r\n            let defaultTo = key !== 'base' && active[key].to;\r\n            if (!defaultTo && 'to' in config) {\r\n                defaultTo = config.to;\r\n            }\r\n            if (!defaultTo && 'attributesFor' in config) {\r\n                defaultTo = key;\r\n            }\r\n            for (const { to, vnode } of renderedNodes) {\r\n                addVnode(teleports, to || defaultTo || 'head', vnode);\r\n            }\r\n        }\r\n        if (slots) {\r\n            for (const slotName in slots) {\r\n                const tagName = slotName === 'default' ? 'head' : slotName;\r\n                // Only teleport the contents of head/body slots\r\n                if (tagName !== 'head' && tagName !== 'body') {\r\n                    continue;\r\n                }\r\n                const slot = slots[slotName];\r\n                if (isFunction(slot)) {\r\n                    addVnode(teleports, tagName, slot({ metainfo: active }));\r\n                }\r\n            }\r\n        }\r\n        return Object.keys(teleports).map((to) => {\r\n            return h(Teleport, { to }, teleports[to]);\r\n        });\r\n    }\r\n}\r\nMetaManager.create = (config, resolver) => {\r\n    const resolve = (options, contexts, active, key, pathSegments) => {\r\n        if (isFunction(resolver)) {\r\n            return resolver(options, contexts, active, key, pathSegments);\r\n        }\r\n        return resolver.resolve(options, contexts, active, key, pathSegments);\r\n    };\r\n    const mergedObject = createMergedObject(resolve, active);\r\n    // TODO: validate resolver\r\n    const manager = new MetaManager(config, mergedObject, resolver);\r\n    return manager;\r\n};\n\n// rollup doesnt like an import as it cant find the export so use require\r\nconst { renderToString } = require('@vue/server-renderer');\r\nasync function renderToStringWithMeta(app) {\r\n    const ctx = {};\r\n    const html = await renderToString(app, ctx);\r\n    // TODO: better way of determining whether meta was rendered with the component or not\r\n    if (!ctx.teleports || !ctx.teleports.head) {\r\n        const teleports = app.config.globalProperties.$metaManager.render();\r\n        await Promise.all(teleports.map((teleport) => renderToString(teleport, ctx)));\r\n    }\r\n    const { teleports } = ctx;\r\n    for (const target in teleports) {\r\n        if (target.endsWith('Attrs')) {\r\n            const str = teleports[target];\r\n            // match from first space to first >, these should be all rendered attributes\r\n            teleports[target] = str.slice(str.indexOf(' ') + 1, str.indexOf('>'));\r\n        }\r\n    }\r\n    return [html, ctx];\r\n}\n\nexport { createMetaManager, deepest as deepestResolver, defaultConfig, getCurrentManager, renderToStringWithMeta, resolveOption, useActiveMeta, useMeta };\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAYA,SAAS,eAAe,OAAO,KAAK;AAClC,MAAI,MAAM;AACV,aAAW,OAAO,OAAO;AACvB,QAAI,iBAAiB,GAAG,KAAK,KAAK,GAAG,KAAK,QAAQ,cAAc,QAAQ,SAAS;AAC/E;AAAA,IACF;AACA,UAAM,QAAQ,MAAM,GAAG;AACvB,QAAI,QAAQ,SAAS;AACnB,aAAO,WAAW,eAAe,KAAK,CAAC;AAAA,IACzC,WAAW,QAAQ,SAAS;AAC1B,aAAO,WAAW,eAAe,KAAK,CAAC;AAAA,IACzC,OAAO;AACL,aAAO,qBAAqB,KAAK,OAAO,GAAG;AAAA,IAC7C;AAAA,EACF;AACA,SAAO;AACT;AACA,SAAS,qBAAqB,KAAK,OAAO,KAAK;AAC7C,MAAI,CAAC,sBAAsB,KAAK,GAAG;AACjC,WAAO;AAAA,EACT;AACA,QAAM,UAAU,QAAQ,IAAI,QAAQ,GAAG,IAAI,KAAK,SAAS,GAAG,KAAK,MAAM,eAAe,GAAG,KAAK,IAAI,YAAY;AAC9G,MAAI,cAAc,OAAO,GAAG;AAC1B,WAAO,mBAAmB,KAAK,IAAI,IAAI,OAAO,KAAK;AAAA,EACrD,WAAW,kBAAkB,OAAO,GAAG;AACrC,WAAO,UAAU,KAAK,IAAI,OAAO,KAAK,IAAI,OAAO,KAAK,WAAW,KAAK,CAAC;AAAA,EACzE,OAAO;AACL,YAAQ;AAAA,MACN,mEAAmE,OAAO;AAAA,IAC5E;AACA,WAAO;AAAA,EACT;AACF;AACA,SAAS,cAAc,KAAK,OAAO;AACjC,MAAI,CAAC,sBAAsB,KAAK,GAAG;AACjC,WAAO;AAAA,EACT;AACA,SAAO,IAAI,GAAG,KAAK,WAAW,KAAK,CAAC;AACtC;AACA,SAAS,eAAe,KAAK;AAC3B,SAAO,WAAW,eAAe,GAAG,CAAC;AACvC;AACA,SAAS,eAAe,KAAK;AAC3B,MAAI,CAAC,KAAK;AACR,WAAO;AAAA,EACT;AACA,MAAI,SAAS,GAAG,GAAG;AACjB,WAAO,WAAW,GAAG;AAAA,EACvB;AACA,QAAM,SAAS,eAAe,GAAG;AACjC,SAAO,WAAW,eAAe,MAAM,CAAC;AAC1C;AAEA,SAAS,mBAAmB,MAAM,QAAQ,MAAM,WAAW,MAAM,kBAAkB,MAAM,aAAa;AACpG,SAAO;AAAA,IACL,YAAY,MAAM,OAAO,QAAQ;AAAA,IACjC;AAAA,IACA;AAAA,EACF;AACF;AAGA,SAAS,cAAc,OAAO,UAAU,WAAW,kBAAkB,MAAM,iBAAiB,aAAa;AACvG,OAAK,UAAU;AACf;AAAA,IACE;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF;AACA,OAAK,UAAU;AACjB;AACA,SAAS,mBAAmB,OAAO,UAAU,WAAW,kBAAkB,MAAM,iBAAiB,aAAa,YAAY;AACxH,QAAM,SAAS,MAAM,QAAQ;AAC7B,MAAI,QAAQ;AACV,UAAM,aAAa,CAAC;AACpB,UAAM,eAAe,CAAC,SAAS;AAC7B,iBAAW,KAAK,IAAI;AAAA,IACtB;AACA,UAAM,MAAM;AAAA,MACV;AAAA,MACA;AAAA,MACA;AAAA,MACA,cAAc,MAAM,cAAc;AAAA,IACpC;AACA,QAAI,QAAQ,GAAG,GAAG;AAChB,YAAM,mBAAmB,iBAAiB,GAAG;AAC7C,UAAI,kBAAkB;AACpB;AAAA,UACE;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,QACF;AAAA,MACF,WAAW,kBAAkB;AAC3B,yBAAiB;AAAA,MACnB;AAAA,IACF,OAAO;AACL,UAAI,cAAc;AAClB,UAAI,YAAY;AACd,sBAAc;AAAA,MAChB,OAAO;AACL,iBAAS,IAAI,GAAG,IAAI,WAAW,QAAQ,KAAK;AAC1C,cAAI,CAAC,UAAU,WAAW,CAAC,CAAC,GAAG;AAC7B,0BAAc;AACd;AAAA,UACF;AAAA,QACF;AAAA,MACF;AACA,UAAI,aAAa;AACf,YAAI,kBAAkB;AACpB,2BAAiB;AAAA,QACnB;AAAA,MACF,OAAO;AACL,YAAI,QAAQ;AACZ,YAAI,MAAM,WAAW;AACrB,YAAI,cAAc,WAAW,CAAC,MAAM,cAAc,WAAW,MAAM,CAAC,MAAM,YAAY;AACpF;AACA;AAAA,QACF;AACA,iBAAS,IAAI,OAAO,IAAI,KAAK,KAAK;AAChC,eAAK,WAAW,CAAC,CAAC;AAAA,QACpB;AAAA,MACF;AAAA,IACF;AAAA,EACF,WAAW,kBAAkB;AAC3B,qBAAiB;AAAA,EACnB;AACF;AAGA,SAAS,UAAU,MAAM;AACvB,MAAI,OAAO,SAAS,YAAY,CAAC,cAAc,KAAK,IAAI,EAAG,QAAO;AAClE,MAAI,KAAK,UAAU,EAAG,QAAO;AAC7B,SAAO,CAAC,KAAK,QAAQ,WAAW,EAAE,EAAE,KAAK;AAC3C;AAEA,SAAS,kBAAkB,YAAY,iBAAiB,QAAQ,UAAU,iBAAiB;AACzF,aAAW,uBAAuB;AAClC,QAAM,UAAU,gBAAgB,WAAW,SAAS,aAAa;AACjE,QAAM,kBAAkB,QAAQ,sBAAsB,QAAQ,oBAAoB,CAAC;AACnF,QAAM,eAAe,gBAAgB,MAAM,MAAM,gBAAgB,MAAM,IAAI,CAAC;AAC5E,QAAM,cAAc,aAAa;AACjC,MAAI;AACJ,MAAI,UAAU;AACZ,oBAAgB,UAAU;AAC1B,sBAAkB;AAAA,EACpB,OAAO;AACL,UAAM,EAAE,WAAW,KAAK,IAAI,aAAa;AACzC,SAAK,8BAA8B;AACnC,oBAAgB,IAAI;AACpB,SAAK,wBAAwB;AAC7B,sBAAkB,UAAU;AAAA,EAC9B;AACA,eAAa,OAAO,aAAa,GAAG,eAAe;AACnD,aAAW,qBAAqB;AAClC;AAEA,SAAS,eAAe,OAAO;AAC7B,SAAO,WAAW,gBAAgB,KAAK,CAAC;AAC1C;AAKA,SAAS,gBAAgB;AACvB,aAAW,KAAK,WAAW;AAC3B,gBAAc;AAChB;AACA,SAAS,gBAAgB;AACvB,QAAM,OAAO,WAAW,IAAI;AAC5B,gBAAc,SAAS,SAAS,OAAO;AACzC;AAiDA,SAAS,MAAM,UAAU;AACvB,QAAM,MAAM,YAAY,SAAS,SAAS;AAC1C,SAAO,MAAM,MAAM,GAAG,IAAI;AAC5B;AAEA,SAAS,MAAM,GAAG;AAChB,SAAO,CAAC,EAAE,KAAK,EAAE,cAAc;AACjC;AAGA,SAAS,mBAAmB,OAAO;AACjC,QAAM,KAAK,KAAK;AAClB;AACA,SAAS,oBAAoB;AAC3B,QAAM,IAAI;AACZ;AAEA,SAAS,OAAO,QAAQ,MAAM;AAC5B,MAAI,UAAW;AACf,cAAY;AACZ,gBAAc;AACd,QAAM,WAAW,MAAM,SAAS,MAAM,MAAM,SAAS,CAAC,EAAE,YAAY;AACpE,QAAM,iBAAiB,YAAY,SAAS,WAAW,OAAO;AAC9D,QAAM,QAAQ,kBAAkB;AAChC,MAAI,gBAAgB;AAClB;AAAA,MACE;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA;AAAA,QAEE,MAAM,KAAK,IAAI,CAAC,MAAM;AACpB,cAAI,IAAI;AACR,kBAAQ,MAAM,KAAK,EAAE,aAAa,OAAO,SAAS,GAAG,KAAK,CAAC,MAAM,OAAO,KAAK,KAAK,UAAU,CAAC;AAAA,QAC/F,CAAC,EAAE,KAAK,EAAE;AAAA,QACV,YAAY,SAAS;AAAA,QACrB,MAAM;AAAA,UACJ,CAAC,EAAE,MAAM,MAAM,OAAO,oBAAoB,UAAU,MAAM,IAAI,CAAC;AAAA,QACjE,EAAE,KAAK,IAAI;AAAA,QACX;AAAA,MACF;AAAA,IACF;AAAA,EACF,OAAO;AACL,UAAM,WAAW,CAAC,eAAe,GAAG,IAAI,GAAG,IAAI;AAC/C,QAAI,MAAM;AAAA,IACV,MAAM;AACJ,eAAS,KAAK;AAAA,GACjB,GAAG,YAAY,KAAK,CAAC;AAAA,IACpB;AACA,YAAQ,KAAK,GAAG,QAAQ;AAAA,EAC1B;AACA,gBAAc;AACd,cAAY;AACd;AACA,SAAS,oBAAoB;AAC3B,MAAI,eAAe,MAAM,MAAM,SAAS,CAAC;AACzC,MAAI,CAAC,cAAc;AACjB,WAAO,CAAC;AAAA,EACV;AACA,QAAM,kBAAkB,CAAC;AACzB,SAAO,cAAc;AACnB,UAAM,OAAO,gBAAgB,CAAC;AAC9B,QAAI,QAAQ,KAAK,UAAU,cAAc;AACvC,WAAK;AAAA,IACP,OAAO;AACL,sBAAgB,KAAK;AAAA,QACnB,OAAO;AAAA,QACP,cAAc;AAAA,MAChB,CAAC;AAAA,IACH;AACA,UAAM,iBAAiB,aAAa,aAAa,aAAa,UAAU;AACxE,mBAAe,kBAAkB,eAAe;AAAA,EAClD;AACA,SAAO;AACT;AACA,SAAS,YAAY,OAAO;AAC1B,QAAM,OAAO,CAAC;AACd,QAAM,QAAQ,CAAC,OAAO,MAAM;AAC1B,SAAK,KAAK,GAAG,MAAM,IAAI,CAAC,IAAI,CAAC;AAAA,CAChC,GAAG,GAAG,iBAAiB,KAAK,CAAC;AAAA,EAC5B,CAAC;AACD,SAAO;AACT;AACA,SAAS,iBAAiB,EAAE,OAAO,aAAa,GAAG;AACjD,QAAM,UAAU,eAAe,IAAI,QAAQ,YAAY,sBAAsB;AAC7E,QAAM,SAAS,MAAM,YAAY,MAAM,UAAU,UAAU,OAAO;AAClE,QAAM,OAAO,QAAQ;AAAA,IACnB,MAAM;AAAA,IACN,MAAM;AAAA,IACN;AAAA,EACF,CAAC;AACD,QAAM,QAAQ,MAAM;AACpB,SAAO,MAAM,QAAQ,CAAC,MAAM,GAAG,YAAY,MAAM,KAAK,GAAG,KAAK,IAAI,CAAC,OAAO,KAAK;AACjF;AACA,SAAS,YAAY,OAAO;AAC1B,QAAM,MAAM,CAAC;AACb,QAAM,OAAO,OAAO,KAAK,KAAK;AAC9B,OAAK,MAAM,GAAG,CAAC,EAAE,QAAQ,CAAC,QAAQ;AAChC,QAAI,KAAK,GAAG,WAAW,KAAK,MAAM,GAAG,CAAC,CAAC;AAAA,EACzC,CAAC;AACD,MAAI,KAAK,SAAS,GAAG;AACnB,QAAI,KAAK,MAAM;AAAA,EACjB;AACA,SAAO;AACT;AACA,SAAS,WAAW,KAAK,OAAO,KAAK;AACnC,MAAI,SAAS,KAAK,GAAG;AACnB,YAAQ,KAAK,UAAU,KAAK;AAC5B,WAAO,MAAM,QAAQ,CAAC,GAAG,GAAG,IAAI,KAAK,EAAE;AAAA,EACzC,WAAW,OAAO,UAAU,YAAY,OAAO,UAAU,aAAa,SAAS,MAAM;AACnF,WAAO,MAAM,QAAQ,CAAC,GAAG,GAAG,IAAI,KAAK,EAAE;AAAA,EACzC,WAAW,MAAM,KAAK,GAAG;AACvB,YAAQ,WAAW,KAAK,MAAM,MAAM,KAAK,GAAG,IAAI;AAChD,WAAO,MAAM,QAAQ,CAAC,GAAG,GAAG,SAAS,OAAO,GAAG;AAAA,EACjD,WAAW,WAAW,KAAK,GAAG;AAC5B,WAAO,CAAC,GAAG,GAAG,MAAM,MAAM,OAAO,IAAI,MAAM,IAAI,MAAM,EAAE,EAAE;AAAA,EAC3D,OAAO;AACL,YAAQ,MAAM,KAAK;AACnB,WAAO,MAAM,QAAQ,CAAC,GAAG,GAAG,KAAK,KAAK;AAAA,EACxC;AACF;AAkCA,SAAS,sBAAsB,IAAI,UAAU,MAAM,MAAM;AACvD,MAAI;AACF,WAAO,OAAO,GAAG,GAAG,IAAI,IAAI,GAAG;AAAA,EACjC,SAAS,KAAK;AACZ,gBAAY,KAAK,UAAU,IAAI;AAAA,EACjC;AACF;AACA,SAAS,YAAY,KAAK,UAAU,MAAM,aAAa,MAAM;AAC3D,QAAM,eAAe,WAAW,SAAS,QAAQ;AACjD,MAAI,UAAU;AACZ,QAAI,MAAM,SAAS;AACnB,UAAM,kBAAkB,SAAS;AACjC,UAAM,YAAY,OAA4C,iBAAiB,IAAI,IAAI,8CAA8C,IAAI;AACzI,WAAO,KAAK;AACV,YAAM,qBAAqB,IAAI;AAC/B,UAAI,oBAAoB;AACtB,iBAAS,IAAI,GAAG,IAAI,mBAAmB,QAAQ,KAAK;AAClD,cAAI,mBAAmB,CAAC,EAAE,KAAK,iBAAiB,SAAS,MAAM,OAAO;AACpE;AAAA,UACF;AAAA,QACF;AAAA,MACF;AACA,YAAM,IAAI;AAAA,IACZ;AACA,UAAM,kBAAkB,SAAS,WAAW,OAAO;AACnD,QAAI,iBAAiB;AACnB,oBAAc;AACd;AAAA,QACE;AAAA,QACA;AAAA,QACA;AAAA,QACA,CAAC,KAAK,iBAAiB,SAAS;AAAA,MAClC;AACA,oBAAc;AACd;AAAA,IACF;AAAA,EACF;AACA,WAAS,KAAK,MAAM,cAAc,UAAU;AAC9C;AACA,SAAS,SAAS,KAAK,MAAM,cAAc,aAAa,MAAM;AAC5D,MAAI,MAA2C;AAC7C,UAAM,OAAO,iBAAiB,IAAI;AAClC,QAAI,cAAc;AAChB,yBAAmB,YAAY;AAAA,IACjC;AACA,WAAO,kBAAkB,OAAO,wBAAwB,IAAI,KAAK,EAAE,EAAE;AACrE,QAAI,cAAc;AAChB,wBAAkB;AAAA,IACpB;AACA,QAAI,YAAY;AACd,YAAM;AAAA,IACR,OAAO;AACL,cAAQ,MAAM,GAAG;AAAA,IACnB;AAAA,EACF,OAAO;AACL,YAAQ,MAAM,GAAG;AAAA,EACnB;AACF;AA4EA,SAAS,iBAAiB,WAAW,kBAAkB,MAAM;AAC3D,SAAO,WAAW,SAAS,IAAI,UAAU,eAAe,UAAU,OAAO,UAAU,QAAQ,mBAAmB,UAAU;AAC1H;AACA,SAAS,oBAAoB,UAAU,WAAW,SAAS,OAAO;AAChE,MAAI,OAAO,iBAAiB,SAAS;AACrC,MAAI,CAAC,QAAQ,UAAU,QAAQ;AAC7B,UAAM,QAAQ,UAAU,OAAO,MAAM,iBAAiB;AACtD,QAAI,OAAO;AACT,aAAO,MAAM,CAAC;AAAA,IAChB;AAAA,EACF;AACA,MAAI,CAAC,QAAQ,YAAY,SAAS,QAAQ;AACxC,UAAM,oBAAoB,CAAC,aAAa;AACtC,iBAAW,OAAO,UAAU;AAC1B,YAAI,SAAS,GAAG,MAAM,WAAW;AAC/B,iBAAO;AAAA,QACT;AAAA,MACF;AAAA,IACF;AACA,WAAO;AAAA,MACL,SAAS,cAAc,SAAS,OAAO,KAAK;AAAA,IAC9C,KAAK,kBAAkB,SAAS,WAAW,UAAU;AAAA,EACvD;AACA,SAAO,OAAO,SAAS,IAAI,IAAI,SAAS,QAAQ;AAClD;AAMA,SAAS,cAAc,QAAQ,YAAY;AACzC,MAAI,QAAQ,MAAM,KAAK,SAAS,MAAM,GAAG;AACvC,aAAS,IAAI,GAAG,IAAI,OAAO,QAAQ,IAAI,GAAG,KAAK;AAC7C,iBAAW,OAAO,CAAC,GAAG,CAAC;AAAA,IACzB;AAAA,EACF,WAAW,OAAO,WAAW,UAAU;AACrC,QAAiD,CAAC,OAAO,UAAU,MAAM,GAAG;AAC1E,MAAAA,MAAK,mDAAmD,MAAM,GAAG;AACjE;AAAA,IACF;AACA,aAAS,IAAI,GAAG,IAAI,QAAQ,KAAK;AAC/B,iBAAW,IAAI,GAAG,CAAC;AAAA,IACrB;AAAA,EACF,WAAW,SAAS,MAAM,GAAG;AAC3B,QAAI,OAAO,OAAO,QAAQ,GAAG;AAC3B,YAAM,MAAM,MAAM,KAAK,MAAM;AAC7B,eAAS,IAAI,GAAG,IAAI,IAAI,QAAQ,IAAI,GAAG,KAAK;AAC1C,mBAAW,IAAI,CAAC,GAAG,CAAC;AAAA,MACtB;AAAA,IACF,OAAO;AACL,YAAM,OAAO,OAAO,KAAK,MAAM;AAC/B,eAAS,IAAI,GAAG,IAAI,KAAK,QAAQ,IAAI,GAAG,KAAK;AAC3C,cAAM,MAAM,KAAK,CAAC;AAClB,mBAAW,OAAO,GAAG,GAAG,KAAK,CAAC;AAAA,MAChC;AAAA,IACF;AAAA,EACF;AACF;AAEA,eAAe,kBAAkB,MAAM,EAAE,SAAS,cAAc,GAAG;AACjE,MAAI,eAAe;AACjB,kBAAc;AAAA,EAChB,OAAO;AACL,SAAK,SAAS;AAAA,EAChB;AACF;AAEA,SAAS,qBAAqB,UAAU,KAAK,OAAO,KAAK,YAAY,CAAC,GAAG;AACvE,MAAI,OAAO,QAAQ,cAAc,IAAI,aAAa;AAChD,WAAO,IAAI;AAAA,MACT;AAAA,QACE;AAAA,QACA,UAAU,SAAS,2BAA2B,SAAS,CAAC;AAAA,QACxD;AAAA,QACA,UAAU;AAAA,QACV;AAAA,QACA;AAAA,MACF;AAAA,MACA;AAAA,IACF,KAAK,CAAC;AAAA,EACR;AACA,SAAO,CAAC;AACV;AAGA,SAAS,gBAAgB,KAAK,OAAO;AACnC,SAAO,aAAa,KAAK,KAAK,IAAI;AACpC;AACA,SAAS,sBAAsB,MAAM,OAAO,OAAO;AACjD,UAAQ,MAAM;AAAA,IACZ,KAAK;AACH,aAAO,WAAW,OAAO,KAAK,IAAI,aAAa;AAAA,IACjD,KAAK;AACH,cAAQ,QAAQ,KAAK,IAAI,gBAAgB,OAAO,KAAK,IAAI,SAAS,aAAa;AAAA,IACjF;AACE,aAAO,cAAc,SAAS,KAAK;AAAA,EACvC;AACF;AACA,SAAS,wBAAwB,gBAAgB,CAAC,GAAG,OAAO;AAC1D,QAAM,EAAE,MAAM,MAAM,IAAI;AACxB,UAAQ,MAAM;AAAA,IACZ,KAAK;AACH,aAAO,WAAW,OAAO,KAAK,IAAI,EAAE,SAAS,KAAK,IAAI;AAAA,IACxD,KAAK;AACH,cAAQ,QAAQ,KAAK,IAAI,gBAAgB,OAAO,KAAK,IAAI,SAAS,EAAE,SAAS,KAAK,IAAI;AAAA,IACxF;AACE,aAAO,EAAE,OAAO,MAAM;AAAA,EAC1B;AACF;AAEA,SAAS,WAAW,UAAU,UAAU;AACtC;AACE,UAAM,IAAI;AAAA,MACR;AAAA,IACF;AAAA,EACF;AACF;AASA,SAAS,eAAe;AACtB,MAAI,aAAa;AACjB,QAAM,SAAS,CAAC;AAChB,SAAO;AAAA,IACL,YAAY;AACV,aAAO;AAAA,IACT;AAAA,IACA,KAAK,MAAM;AACT,YAAM,eAAe,SAAS,IAAI;AAClC,UAAI,cAAc,cAAc;AAC9B,eAAO,OAAO,SAAS,CAAC,KAAK;AAC7B;AAAA,MACF;AACA,aAAO,KAAK,IAAI;AAChB,mBAAa;AACb,UAAI,UAAU,IAAI,KAAK,QAAQ,IAAI,KAAK,KAAK,UAAU;AACrD,eAAO,WAAW;AAAA,MACpB;AAAA,IACF;AAAA,EACF;AACF;AACA,SAAS,qBAAqB,OAAO,kBAAkB,MAAM,aAAa;AACxE,QAAM,WAAW,wBAAwB,OAAO,iBAAiB,IAAI;AACrE,QAAM,MAAM;AAAA,IACV;AAAA,IACA;AAAA;AAAA,EAEF;AACA,QAAM,gBAAgB,UAAU,GAAG;AACnC,QAAM,aAAa,SAAS;AAC5B,MAAI,iBAAiB,YAAY;AAC/B,QAAI,IAAI,gBAAgB,MAAM,QAAQ,QAAQ;AAC9C,QAAI,YAAY;AACd,UAAI,EAAE;AAAA,QACJ,MAAM,QAAQ;AAAA,UACZ,WAAW,IAAI,CAAC,aAAa,SAAS,KAAK,SAAS,KAAK,CAAC;AAAA,QAC5D;AAAA,MACF,EAAE,MAAM,IAAI;AAAA,IACd;AACA,WAAO,EAAE,KAAK,MAAM,uBAAuB,UAAU,WAAW,CAAC;AAAA,EACnE,OAAO;AACL,WAAO,uBAAuB,UAAU,WAAW;AAAA,EACrD;AACF;AACA,SAAS,uBAAuB,UAAU,aAAa;AACrD,QAAM,OAAO,SAAS;AACtB,QAAM,EAAE,WAAW,KAAK,IAAI,aAAa;AACzC,MAAI,WAAW,IAAI,GAAG;AACpB,QAAI,OAAO,oBAAoB,QAAQ;AACvC,QAAI,CAAC,KAAK,OAAO;AACf,iBAAW,OAAO,SAAS,OAAO;AAChC,YAAI,IAAI,WAAW,SAAS,GAAG;AAC7B,WAAC,KAAK,UAAU,KAAK,QAAQ,CAAC,IAAI,GAAG,IAAI;AAAA,QAC3C;AAAA,MACF;AAAA,IACF;AACA,gBAAY,MAAM,SAAS,UAAU,MAAM,UAAU,WAAW;AAAA,EAClE,OAAO;AACL,SAAK,CAAC,SAAS,UAAU,SAAS,WAAW,SAAS,CAAC,SAAS,aAAa,CAAC,KAAK,aAAa,SAAS,KAAK,QAAQ,GAAG;AACvH,WAAK,YAAY,WAAW,KAAK,QAAQ;AAAA,IAC3C;AACA,eAAW,KAAK,SAAS,MAAM,SAAS;AACtC,UAAI,EAAE,UAAU;AACd,UAAE,SAAS,SAAS;AACpB,UAAE,SAAS,aAAa;AAAA,MAC1B;AAAA,IACF;AACA,UAAM,YAAY,SAAS,aAAa,KAAK;AAC7C,QAAI,WAAW;AACb,UAAI,QAAQ,SAAS,iBAAiB,QAAQ,SAAS,QAAQ;AAC/D,UAAI,YAAY;AAChB,UAAI,MAAM;AACV,aAAO,MAAM;AACX,cAAM,UAAU,IAAI,MAAM;AAC1B,YAAI,SAAS;AACX,cAAI,CAAC,WAAW;AACd,oBAAQ,EAAE,GAAG,MAAM;AACnB,wBAAY;AAAA,UACd;AACA,gBAAM,OAAO,IAAI;AAAA,QACnB;AACA,cAAM,SAAS,IAAI;AACnB,YAAI,UAAU,OAAO,WAAW,OAAO,YAAY,IAAI,OAAO;AAC5D,gBAAM;AAAA,QACR,OAAO;AACL;AAAA,QACF;AAAA,MACF;AACA,UAAI,aAAa;AACf,YAAI,CAAC,UAAW,SAAQ,EAAE,GAAG,MAAM;AACnC,cAAM,kBAAkB,YAAY,KAAK,EAAE,MAAM,GAAG;AACpD,iBAAS,IAAI,GAAG,IAAI,gBAAgB,QAAQ,KAAK;AAC/C,gBAAM,gBAAgB,CAAC,CAAC,IAAI;AAAA,QAC9B;AAAA,MACF;AACA,YAAM,OAAO,4BAA4B,QAAQ;AACjD,UAAI;AACF;AAAA,UACE,SAAS;AAAA,UACT;AAAA,UACA;AAAA,UACA;AAAA;AAAA,UAEA,SAAS;AAAA,UACT,SAAS;AAAA,UACT,SAAS;AAAA,UACT,SAAS;AAAA,QACX;AAAA,MACF,UAAE;AACA,oCAA4B,IAAI;AAAA,MAClC;AAAA,IACF,WAAW,SAAS,UAAU,SAAS,WAAW,MAAM;AACtD;AAAA,QACE;AAAA,QACA,SAAS,UAAU,oBAAoB,QAAQ;AAAA,QAC/C;AAAA,QACA;AAAA,MACF;AAAA,IACF,OAAO;AACL,YAAM,gBAAgB,KAAK,QAAQ,KAAK,UAAU;AAClD,WAAO,aAAa,aAAa,0CAA0C;AAC3E,WAAK,SAAS;AAAA,IAChB;AAAA,EACF;AACA,SAAO,UAAU;AACnB;AACA,SAAS,YAAY,MAAM,OAAO,iBAAiB,aAAa;AAC9D,QAAM,EAAE,MAAM,WAAW,SAAS,IAAI;AACtC,UAAQ,MAAM;AAAA,IACZ,KAAK;AACH,WAAK,WAAW,QAAQ,CAAC;AACzB;AAAA,IACF,KAAK;AACH;AAAA,QACE,WAAW,OAAO,kBAAkB,QAAQ,CAAC,QAAQ;AAAA,MACvD;AACA;AAAA,IACF,KAAK;AACH,WAAK,QAAQ;AACb;AAAA,IACF,KAAK;AACH,UAAI,MAAM,cAAc;AACtB,uBAAe,cAAc,cAAc,MAAM,MAAM,MAAM,aAAa,KAAK,GAAG;AAAA,MACpF;AACA,WAAK,UAAU;AACf;AAAA,QACE;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,MACF;AACA,WAAK,UAAU;AACf;AAAA,IACF;AACE,UAAI,YAAY,GAAG;AACjB,2BAAmB,MAAM,OAAO,iBAAiB,WAAW;AAAA,MAC9D,WAAW,YAAY,GAAG;AACxB,aAAK,qBAAqB,OAAO,iBAAiB,WAAW,CAAC;AAAA,MAChE,WAAW,YAAY,IAAI;AACzB,4BAAoB,MAAM,OAAO,iBAAiB,WAAW;AAAA,MAC/D,WAAW,YAAY,KAAK;AAC1B,oBAAY,MAAM,MAAM,WAAW,iBAAiB,WAAW;AAAA,MACjE,OAAO;AACL;AAAA,UACE;AAAA,UACA;AAAA,UACA,IAAI,OAAO,IAAI;AAAA,QACjB;AAAA,MACF;AAAA,EACJ;AACF;AACA,SAAS,oBAAoB,MAAM,UAAU,iBAAiB,aAAa;AACzE,WAAS,IAAI,GAAG,IAAI,SAAS,QAAQ,KAAK;AACxC,gBAAY,MAAM,eAAe,SAAS,CAAC,CAAC,GAAG,iBAAiB,WAAW;AAAA,EAC7E;AACF;AACA,SAAS,mBAAmB,MAAM,OAAO,iBAAiB,aAAa;AACrE,QAAM,MAAM,MAAM;AAClB,MAAI,EAAE,OAAO,UAAU,WAAW,SAAS,KAAK,IAAI;AACpD,MAAI,UAAU,IAAI,GAAG;AACrB,MAAI,MAAM;AACR,YAAQ,mBAAmB,OAAO,OAAO,IAAI;AAAA,EAC/C;AACA,MAAI,OAAO;AACT,eAAW,eAAe,OAAO,GAAG;AAAA,EACtC;AACA,MAAI,SAAS;AACX,eAAW,IAAI,OAAO;AAAA,EACxB;AACA,MAAI,YAAY;AAChB,MAAI,WAAW;AACf,SAAO,aAAa,aAAa,UAAU,SAAS;AAClD,eAAW,UAAU;AACrB,QAAI,SAAS,SAAS;AACpB,iBAAW,IAAI,SAAS,OAAO;AAAA,IACjC;AACA,gBAAY,UAAU;AAAA,EACxB;AACA,MAAI,aAAa;AACf,eAAW,IAAI,WAAW;AAAA,EAC5B;AACA,OAAK,UAAU,GAAG;AAClB,MAAI,CAAC,UAAU,GAAG,GAAG;AACnB,QAAI,sBAAsB;AAC1B,QAAI,OAAO;AACT,UAAI,MAAM,WAAW;AACnB,8BAAsB;AACtB,aAAK,MAAM,SAAS;AAAA,MACtB,WAAW,MAAM,aAAa;AAC5B,8BAAsB;AACtB,aAAK,WAAW,MAAM,WAAW,CAAC;AAAA,MACpC,WAAW,QAAQ,cAAc,MAAM,OAAO;AAC5C,8BAAsB;AACtB,aAAK,WAAW,MAAM,KAAK,CAAC;AAAA,MAC9B;AAAA,IACF;AACA,QAAI,CAAC,qBAAqB;AACxB,UAAI,YAAY,GAAG;AACjB,aAAK,WAAW,QAAQ,CAAC;AAAA,MAC3B,WAAW,YAAY,IAAI;AACzB;AAAA,UACE;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,QACF;AAAA,MACF;AAAA,IACF;AACA,SAAK,KAAK,GAAG,GAAG;AAAA,EAClB;AACF;AACA,SAAS,mBAAmB,OAAO,UAAU,MAAM;AACjD,QAAM,UAAU,CAAC;AACjB,WAAS,IAAI,GAAG,IAAI,KAAK,QAAQ,KAAK;AACpC,UAAM,UAAU,KAAK,CAAC;AACtB,UAAM;AAAA,MACJ,KAAK,EAAE,YAAY;AAAA,IACrB,IAAI;AACJ,QAAI,aAAa;AACf,YAAM,QAAQ,YAAY,SAAS,KAAK;AACxC,UAAI,MAAO,SAAQ,KAAK,KAAK;AAAA,IAC/B;AAAA,EACF;AACA,SAAO,WAAW,YAAY,CAAC,GAAG,GAAG,OAAO;AAC9C;AACA,SAAS,oBAAoB,MAAM,OAAO,iBAAiB,aAAa;AACtE,QAAM,SAAS,MAAM,SAAS,MAAM,MAAM;AAC1C,QAAM,WAAW,MAAM,SAAS,MAAM,MAAM;AAC5C,MAAI,CAAC,QAAQ;AACX,QAAI,CAAC,UAAU;AACb,WAAO,yDAAyD;AAAA,IAClE;AACA,WAAO,CAAC;AAAA,EACV;AACA,MAAI,CAAC,SAAS,MAAM,GAAG;AACrB;AAAA,MACE;AAAA,IACF;AACA,WAAO,CAAC;AAAA,EACV;AACA;AAAA,IACE;AAAA,IACA,CAAC,UAAU;AACT;AAAA,QACE;AAAA,QACA,MAAM;AAAA,QACN;AAAA,QACA;AAAA,MACF;AAAA,IACF;AAAA,IACA;AAAA,IACA,YAAY,aAAa;AAAA,IACzB;AAAA,EACF;AACF;AAGA,SAAS,mBAAmB,QAAQ,WAAW,YAAY;AACzD,MAAI,CAAC,OAAO,UAAU;AACpB,WAAO,YAAY,mBAAmB,MAAM;AAAA,EAC9C;AACA,MAAI,MAAM;AACV,WAAS,IAAI,YAAY,IAAI,OAAO,QAAQ,KAAK,GAAG;AAClD,UAAM,OAAO,OAAO,CAAC;AACrB,QAAI,SAAS,IAAI,GAAG;AAClB,aAAO;AACP;AAAA,IACF;AACA,QAAI,UAAU,IAAI,GAAG;AACnB,aAAO,KAAK,KAAK,CAAC,eAAe;AAC/B,eAAO,CAAC,IAAI;AACZ,eAAO,mBAAmB,QAAQ,KAAK,CAAC;AAAA,MAC1C,CAAC;AAAA,IACH;AACA,UAAM,SAAS,mBAAmB,MAAM,KAAK,CAAC;AAC9C,QAAI,UAAU,MAAM,GAAG;AACrB,aAAO,OAAO,KAAK,CAAC,eAAe;AACjC,eAAO,CAAC,IAAI;AACZ,eAAO,mBAAmB,QAAQ,IAAI,CAAC;AAAA,MACzC,CAAC;AAAA,IACH;AACA,UAAM;AAAA,EACR;AACA,SAAO;AACT;AACA,SAAS,eAAe,QAAQ;AAC9B,SAAO,mBAAmB,QAAQ,IAAI,CAAC;AACzC;AACA,SAAS,mBAAmB,QAAQ;AAClC,MAAI,MAAM;AACV,WAAS,IAAI,GAAG,IAAI,OAAO,QAAQ,KAAK;AACtC,QAAI,OAAO,OAAO,CAAC;AACnB,QAAI,SAAS,IAAI,GAAG;AAClB,aAAO;AAAA,IACT,OAAO;AACL,aAAO,mBAAmB,IAAI;AAAA,IAChC;AAAA,EACF;AACA,SAAO;AACT;AACA,eAAe,eAAe,OAAO,UAAU,CAAC,GAAG;AACjD,MAAI,UAAU,KAAK,GAAG;AACpB,WAAO,eAAe,UAAU,EAAE,QAAQ,MAAM,MAAM,CAAC,GAAG,OAAO;AAAA,EACnE;AACA,QAAM,QAAQ,YAAY,MAAM,YAAY,MAAM,MAAM;AACxD,QAAM,aAAa,MAAM;AACzB,QAAM,QAAQ,eAAe,OAAO;AACpC,QAAM,SAAS,MAAM,qBAAqB,KAAK;AAC/C,QAAM,SAAS,MAAM,eAAe,MAAM;AAC1C,QAAM,iBAAiB,OAAO;AAC9B,MAAI,QAAQ,kBAAkB;AAC5B,eAAW,WAAW,QAAQ,kBAAkB;AAC9C,cAAQ;AAAA,IACV;AAAA,EACF;AACA,SAAO;AACT;AACA,eAAe,iBAAiB,SAAS;AACvC,MAAI,QAAQ,mBAAmB;AAC7B,YAAQ,YAAY,QAAQ,aAAa,CAAC;AAC1C,eAAW,OAAO,QAAQ,mBAAmB;AAC3C,cAAQ,UAAU,GAAG,IAAI,MAAM;AAAA,QAC7B,MAAM,QAAQ,IAAI,CAAC,QAAQ,kBAAkB,GAAG,CAAC,CAAC;AAAA,MACpD;AAAA,IACF;AAAA,EACF;AACF;AAGA,eAAe,aAAa,QAAQ,QAAQ;AAC1C,MAAI,OAAO,UAAU;AACnB,aAAS,IAAI,GAAG,IAAI,OAAO,QAAQ,KAAK;AACtC,UAAI,OAAO,OAAO,CAAC;AACnB,UAAI,UAAU,IAAI,GAAG;AACnB,eAAO,MAAM;AAAA,MACf;AACA,UAAI,SAAS,IAAI,GAAG;AAClB,eAAO,KAAK,IAAI;AAAA,MAClB,OAAO;AACL,cAAM,aAAa,MAAM,MAAM;AAAA,MACjC;AAAA,IACF;AAAA,EACF,OAAO;AACL,qBAAiB,QAAQ,MAAM;AAAA,EACjC;AACF;AACA,SAAS,iBAAiB,QAAQ,QAAQ;AACxC,WAAS,IAAI,GAAG,IAAI,OAAO,QAAQ,KAAK;AACtC,QAAI,OAAO,OAAO,CAAC;AACnB,QAAI,SAAS,IAAI,GAAG;AAClB,aAAO,KAAK,IAAI;AAAA,IAClB,OAAO;AACL,uBAAiB,MAAM,MAAM;AAAA,IAC/B;AAAA,EACF;AACF;AACA,SAAS,qBAAqB,OAAO,SAAS,QAAQ;AACpD,MAAI,QAAQ,KAAK,GAAG;AAClB,WAAO;AAAA,MACL,UAAU,EAAE,QAAQ,MAAM,MAAM,CAAC;AAAA,MACjC;AAAA,MACA;AAAA,IACF;AAAA,EACF;AACA,QAAM,QAAQ,YAAY,MAAM,YAAY,MAAM,MAAM;AACxD,QAAM,aAAa,MAAM;AACzB,QAAM,QAAQ,eAAe,OAAO;AACpC,UAAQ,QAAQ,qBAAqB,KAAK,CAAC,EAAE,KAAK,CAAC,WAAW,aAAa,QAAQ,MAAM,CAAC,EAAE,KAAK,MAAM,iBAAiB,OAAO,CAAC,EAAE,KAAK,MAAM;AAC3I,QAAI,QAAQ,kBAAkB;AAC5B,iBAAW,WAAW,QAAQ,kBAAkB;AAC9C,gBAAQ;AAAA,MACV;AAAA,IACF;AAAA,EACF,CAAC,EAAE,KAAK,MAAM,OAAO,KAAK,IAAI,CAAC,EAAE,MAAM,CAAC,UAAU;AAChD,WAAO,QAAQ,KAAK;AAAA,EACtB,CAAC;AACD,SAAO;AACT;AACA,SAAS,eAAe,OAAO,UAAU,CAAC,GAAG;AAC3C,UAAQ;AAAA,IACN;AAAA,EACF;AACA,SAAO,mBAAmB,OAAO,OAAO;AAC1C;AACA,SAAS,mBAAmB,OAAO,UAAU,CAAC,GAAG;AAC/C;AACE,UAAM,IAAI;AAAA,MACR;AAAA,IACF;AAAA,EACF;AACF;AACA,SAAS,mBAAmB,OAAO,UAAU,CAAC,GAAG,UAAU;AACzD,uBAAqB,OAAO,SAAS;AAAA,IACnC,KAAK,SAAS;AACZ,UAAI,WAAW,MAAM;AACnB,iBAAS,MAAM,OAAO;AAAA,MACxB,OAAO;AACL,iBAAS,IAAI;AAAA,MACf;AAAA,IACF;AAAA,IACA,QAAQ,KAAK;AACX,eAAS,QAAQ,GAAG;AAAA,IACtB;AAAA,EACF,CAAC;AACH;AACA,SAAS,kBAAkB,OAAO,UAAU,CAAC,GAAG;AAC9C,MAAI,OAAO,mBAAmB,YAAY;AACxC,UAAM,IAAI;AAAA,MACR;AAAA,IACF;AAAA,EACF;AACA,QAAM,UAAU,IAAI,YAAY;AAChC,MAAI,YAAY;AAChB,SAAO,IAAI,eAAe;AAAA,IACxB,MAAM,YAAY;AAChB,2BAAqB,OAAO,SAAS;AAAA,QACnC,KAAK,SAAS;AACZ,cAAI,UAAW;AACf,cAAI,WAAW,MAAM;AACnB,uBAAW,QAAQ,QAAQ,OAAO,OAAO,CAAC;AAAA,UAC5C,OAAO;AACL,uBAAW,MAAM;AAAA,UACnB;AAAA,QACF;AAAA,QACA,QAAQ,KAAK;AACX,qBAAW,MAAM,GAAG;AAAA,QACtB;AAAA,MACF,CAAC;AAAA,IACH;AAAA,IACA,SAAS;AACP,kBAAY;AAAA,IACd;AAAA,EACF,CAAC;AACH;AACA,SAAS,kBAAkB,OAAO,UAAU,CAAC,GAAG,UAAU;AACxD,QAAM,SAAS,SAAS,UAAU;AAClC,QAAM,UAAU,IAAI,YAAY;AAChC,MAAI,WAAW;AACf,MAAI;AACF,eAAW,UAAU,OAAO,KAAK;AAAA,EACnC,SAAS,GAAG;AAAA,EACZ;AACA,uBAAqB,OAAO,SAAS;AAAA,IACnC,MAAM,KAAK,SAAS;AAClB,UAAI,UAAU;AACZ,cAAM,OAAO;AAAA,MACf;AACA,UAAI,WAAW,MAAM;AACnB,eAAO,OAAO,MAAM,QAAQ,OAAO,OAAO,CAAC;AAAA,MAC7C,OAAO;AACL,eAAO,OAAO,MAAM;AAAA,MACtB;AAAA,IACF;AAAA,IACA,QAAQ,KAAK;AACX,cAAQ,IAAI,GAAG;AACf,aAAO,MAAM;AAAA,IACf;AAAA,EACF,CAAC;AACH;AAtmCA,IASM,kBAgEE,kBAuEF,eACA,WAiCF,aACE,YAkEA,OAOF,WA0GE,kBAmKA,YACA,UA2BAA,OA0DA,eAmCJ,yBACA,6BACA,gBACA,qBACA,gBAsRe,WAwET;AAp+BR;AAAA;AAKA;AACA;AACA;AAEA,IAAM,mBAAmC;AAAA,MACvC;AAAA,IACF;AA8DA,KAAM,EAAE,qBAAqB;AAuE7B,IAAM,gBAAgB;AACtB,IAAM,YAAY;AAiClB,IAAI,cAAc;AAClB,IAAM,aAAa,CAAC;AAiCpB,WAAO,OAA4C,YAAY,EAAE;AACjE,WAAO,OAA4C,oBAAoB,EAAE;AAgCzE,IAAM,QAAQ,CAAC;AAOf,IAAI,YAAY;AA0GhB,IAAM,mBAAmB;AAAA,MACvB,CAAC,IAAI,GAAG;AAAA,MACR,CAAC,IAAI,GAAG;AAAA,MACR,CAAC,GAAG,GAAG;AAAA,MACP,CAAC,IAAI,GAAG;AAAA,MACR,CAAC,GAAG,GAAG;AAAA,MACP,CAAC,IAAI,GAAG;AAAA,MACR,CAAC,GAAG,GAAG;AAAA,MACP,CAAC,KAAK,GAAG;AAAA,MACT,CAAC,IAAI,GAAG;AAAA,MACR,CAAC,GAAG,GAAG;AAAA,MACP,CAAC,IAAI,GAAG;AAAA,MACR,CAAC,IAAI,GAAG;AAAA,MACR,CAAC,KAAK,GAAG;AAAA,MACT,CAAC,KAAK,GAAG;AAAA,MACT,CAAC,CAAC,GAAG;AAAA,MACL,CAAC,CAAC,GAAG;AAAA,MACL,CAAC,CAAC,GAAG;AAAA,MACL,CAAC,CAAC,GAAG;AAAA,MACL,CAAC,CAAC,GAAG;AAAA,MACL,CAAC,CAAC,GAAG;AAAA,MACL,CAAC,CAAC,GAAG;AAAA,MACL,CAAC,CAAC,GAAG;AAAA,MACL,CAAC,CAAC,GAAG;AAAA,MACL,CAAC,CAAC,GAAG;AAAA,MACL,CAAC,EAAE,GAAG;AAAA,MACN,CAAC,EAAE,GAAG;AAAA,MACN,CAAC,EAAE,GAAG;AAAA,MACN,CAAC,EAAE,GAAG;AAAA,MACN,CAAC,EAAE,GAAG;AAAA,MACN,CAAC,EAAE,GAAG;AAAA,IACR;AA6FA;AACE,YAAM,IAAI,cAAc;AACxB,YAAM,uBAAuB,CAAC,KAAK,WAAW;AAC5C,YAAI;AACJ,YAAI,EAAE,UAAU,EAAE,GAAG,GAAI,WAAU,EAAE,GAAG,IAAI,CAAC;AAC7C,gBAAQ,KAAK,MAAM;AACnB,eAAO,CAAC,MAAM;AACZ,cAAI,QAAQ,SAAS,EAAG,SAAQ,QAAQ,CAAC,QAAQ,IAAI,CAAC,CAAC;AAAA,cAClD,SAAQ,CAAC,EAAE,CAAC;AAAA,QACnB;AAAA,MACF;AACA;AAAA,QACE;AAAA,QACA,CAAC,MAAM;AAAA,MACT;AACA;AAAA,QACE;AAAA,QACA,CAAC,MAAM;AAAA,MACT;AAAA,IACF;AAoBA,IAAM,aAAa;AACnB,IAAM,WAAW,CAAC,QAAQ,IAAI,QAAQ,YAAY,CAAC,MAAM,EAAE,YAAY,CAAC,EAAE,QAAQ,SAAS,EAAE;AA2B7F,IAAMA,QAAO,OAA4C,SAAS;AA0DlE,IAAM,gBAAgB;AAkCtB,KAAM;AAAA,MACJ;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,QACE;AAqRJ,KAAM,EAAE,SAAS,cAAc;AAwE/B,KAAM,EAAE,YAAY;AAoIpB,yBAAqB;AAAA;AAAA;;;AChmCrB;AAEA,IAAM,gBAAgB,iBAAe,CAAC,SAAS,aAAa;AACxD,MAAI,gBAAgB;AACpB,WAAS,OAAO,CAAC,KAAK,SAAS,UAAU;AACrC,UAAM,SAAS,YAAY,KAAK,OAAO;AACvC,QAAI,WAAW,KAAK;AAChB,sBAAgB;AAChB,aAAO;AAAA,IACX;AACA,WAAO;AAAA,EACX,GAAG,MAAS;AACZ,MAAI,gBAAgB,IAAI;AACpB,WAAO,QAAQ,aAAa;AAAA,EAChC;AACJ;AAEA,SAAS,MAAM,SAAS;AACpB,MAAI,QAAQ;AACZ,MAAI,QAAQ,IAAI;AACZ,QAAI,EAAE,GAAG,IAAI;AACb,OAAG;AACC,UAAI,GAAG,QAAQ;AACX;AACA,aAAK,GAAG;AAAA,MACZ;AAAA,IACJ,SAAS,MAAM,GAAG,UAAU,OAAO,GAAG;AAAA,EAC1C;AACA,UAAQ,QAAQ;AACpB;AACA,IAAM,UAAU,cAAc,CAAC,KAAK,YAAY;AAC5C,QAAM,EAAE,MAAM,IAAI;AAClB,MAAI,CAAC,OAAO,QAAQ,KAAK;AACrB,WAAO;AAAA,EACX;AACJ,CAAC;AAED,IAAI,UAAuB,OAAO,OAAO;AAAA,EACvC,WAAW;AAAA,EACX;AAAA,EACA;AACF,CAAC;AAED,IAAM,gBAAgB;AAAA,EAClB,MAAM;AAAA,IACF,KAAK;AAAA,IACL,IAAI;AAAA,EACR;AAAA,EACA,MAAM;AAAA,IACF,gBAAgB;AAAA,EACpB;AAAA,EACA,SAAS;AAAA,IACL,KAAK;AAAA,IACL,UAAU;AAAA,IACV,gBAAgB;AAAA,EACpB;AAAA,EACA,aAAa;AAAA,IACT,KAAK;AAAA,EACT;AAAA,EACA,IAAI;AAAA,IACA,OAAO;AAAA,IACP,qBAAqB;AAAA,IACrB,KAAK;AAAA,IACL,cAAc;AAAA,EAClB;AAAA,EACA,SAAS;AAAA,IACL,OAAO;AAAA,IACP,qBAAqB;AAAA,IACrB,KAAK;AAAA,EACT;AAAA,EACA,WAAW;AAAA,IACP,eAAe;AAAA,EACnB;AAAA,EACA,WAAW;AAAA,IACP,eAAe;AAAA,EACnB;AAAA,EACA,WAAW;AAAA,IACP,eAAe;AAAA,EACnB;AACJ;AAKA,IAAM,OAAO;AAAA,EACT,OAAO;AAAA,IACH,YAAY;AAAA,EAChB;AAAA,EACA,MAAM;AAAA,IACF,oBAAoB;AAAA,IACpB,YAAY,CAAC,QAAQ,QAAQ;AAAA,EACjC;AAAA,EACA,MAAM;AAAA,IACF,oBAAoB;AAAA,IACpB,cAAc;AAAA,IACd,YAAY,CAAC,WAAW,QAAQ,cAAc,SAAS;AAAA,EAC3D;AAAA,EACA,MAAM;AAAA,IACF,oBAAoB;AAAA,IACpB,YAAY;AAAA,MACR;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACJ;AAAA,EACJ;AAAA,EACA,OAAO;AAAA,IACH,YAAY,CAAC,OAAO;AAAA,EACxB;AAAA,EACA,QAAQ;AAAA,IACJ,YAAY;AAAA,MACR;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACJ;AAAA,EACJ;AAAA,EACA,UAAU;AAAA,IACN,YAAY;AAAA,EAChB;AACJ;AAEA,SAAS,iBAAiB,WAAW,KAAK;AACtC,aAAW,QAAQ,WAAW;AAC1B,UAAM,MAAM,KAAK,IAAI;AACrB,QAAI,QAAQ,KAAK;AACb,aAAO,IAAI,GAAG;AAAA,IAClB;AAAA,EACJ;AACJ;AASC,OACK,OAAO,OAAO,CAAC,CAAC,IAChB,CAAC;AACN,OAAyC,OAAO,OAAO,CAAC,CAAC,IAAI,CAAC;AAC/D,IAAMC,WAAU,MAAM;AACtB,IAAMC,cAAa,CAAC,QAAQ,OAAO,QAAQ;AAC3C,IAAMC,YAAW,CAAC,QAAQ,OAAO,QAAQ;AACzC,IAAMC,YAAW,CAAC,QAAQ,QAAQ,QAAQ,OAAO,QAAQ;AACzD,IAAM,iBAAiB,OAAO,UAAU;AACxC,IAAM,eAAe,CAAC,UAAU,eAAe,KAAK,KAAK;AACzD,IAAM,gBAAgB,CAAC,QAAQ,aAAa,GAAG,MAAM;AAGrD,IAAM,WAAW,OAAO,UAAU;AAClC,IAAM,gBAAgB,OAAO,eAAe;AAC5C,IAAM,eAAe,OAAO,cAAc;AAC1C,IAAM,kBAAkB,OAAO,iBAAiB;AAGhD,SAAS,MAAM,GAAG;AACd,MAAIH,SAAQ,CAAC,GAAG;AACZ,WAAO,EAAE,IAAI,KAAK;AAAA,EACtB;AACA,MAAIG,UAAS,CAAC,GAAG;AACb,UAAM,MAAM,CAAC;AACb,eAAW,OAAO,GAAG;AAEjB,UAAI,QAAQ,WAAW;AACnB,YAAI,GAAG,IAAI,EAAE,GAAG;AAAA,MACpB,OACK;AACD,YAAI,GAAG,IAAI,MAAM,EAAE,GAAG,CAAC;AAAA,MAC3B;AAAA,IACJ;AACA,WAAO;AAAA,EACX;AACA,SAAO;AACX;AAEA,IAAM,QAAQ,CAAC,YAAY,KAAK,aAAa;AACzC,QAAM,UAAU,CAAC;AACjB,aAAW,OAAO,YAAY;AAC1B,QAAI,OAAO,KAAK;AACZ,cAAQ,KAAK,IAAI,GAAG,CAAC;AACrB,UAAI,UAAU;AACV,iBAAS,GAAG;AAAA,MAChB;AAAA,IACJ;AAAA,EACJ;AACA,SAAO;AACX;AAEA,IAAM,UAAU,CAAC,WAAW,YAAY;AACpC,QAAM,OAAO,SAAS,OAAO,KAAK,MAAM,IAAI,CAAC;AAC7C,MAAI,SAAS;AACT,eAAWC,WAAU,SAAS;AAC1B,UAAI,CAACA,WAAU,CAACD,UAASC,OAAM,GAAG;AAC9B;AAAA,MACJ;AACA,iBAAW,OAAOA,SAAQ;AACtB,YAAI,CAAC,KAAK,SAAS,GAAG,GAAG;AACrB,eAAK,KAAK,GAAG;AAAA,QACjB;AAAA,MACJ;AAAA,IACJ;AAAA,EACJ;AAEA,SAAO;AACX;AACA,IAAM,YAAY,CAAC,SAAS,SAAS,QAAQ,OAAO,CAAC,MAAM;AACvD,MAAI,CAAC,KAAK,QAAQ;AACd,QAAI,CAAC,QAAQ;AACT,eAAS,QAAQ;AAAA,IACrB;AACA,QAAI,CAAC,SAAS;AACV,gBAAU,QAAQ;AAAA,IACtB;AAAA,EACJ;AACA,MAAI,CAAC,UAAU,CAAC,SAAS;AACrB;AAAA,EACJ;AACA,QAAM,OAAO,QAAQ,GAAG,OAAO;AAE/B,QAAM,aAAa,OAAO,KAAK,MAAM;AACrC,aAAW,OAAO,YAAY;AAC1B,QAAI,CAAC,KAAK,SAAS,GAAG,GAAG;AACrB,aAAO,OAAO,GAAG;AAAA,IACrB;AAAA,EACJ;AACA,aAAW,OAAO,MAAM;AAEpB,QAAI,cAAc,QAAQ,CAAC,EAAE,GAAG,CAAC,GAAG;AAChC,UAAI,CAAC,OAAO,GAAG,GAAG;AACd,eAAO,GAAG,IAAI,CAAC;AAAA,MACnB;AACA,YAAMC,cAAa,CAAC;AACpB,iBAAW,UAAU,SAAS;AAC1B,YAAI,OAAO,QAAQ;AACf,UAAAA,YAAW,KAAK,OAAO,GAAG,CAAC;AAAA,QAC/B;AAAA,MACJ;AACA,gBAAU,SAASA,aAAY,OAAO,GAAG,GAAG,CAAC,GAAG,MAAM,GAAG,CAAC;AAC1D;AAAA,IACJ;AAEA,QAAI,CAAC,OAAO,GAAG,KAAKL,SAAQ,QAAQ,CAAC,EAAE,GAAG,CAAC,GAAG;AAC1C,aAAO,GAAG,IAAI,CAAC;AAAA,IACnB;AACA,UAAM,cAAc,CAAC;AACrB,UAAM,aAAa,MAAM,SAAS,KAAK,YAAU,YAAY,KAAK,OAAO,eAAe,CAAC,CAAC;AAC1F,QAAI,WAAW,QAAQ,QAAQ,YAAY,aAAa,OAAO,GAAG,GAAG,KAAK,IAAI;AAC9E,QAAI,cAAc,QAAQ,GAAG;AACzB,iBAAW,MAAM,QAAQ;AAAA,IAC7B;AAEA,WAAO,GAAG,IAAI;AAAA,EAClB;AACJ;AAEA,IAAM,cAAc,CAAC,SAAS,QAAQ,gBAAgB,eAAe,CAAC,MAAM;AACxE,QAAM,UAAU,cAAc,SAAS,gBAAgB,YAAY;AACnE,QAAM,QAAQ,QAAQ,IAAI,MAAM,QAAQ,OAAO,CAAC;AAChD,MAAI,CAAC,aAAa,UAAU,QAAQ,SAAS;AACzC,YAAQ,QAAQ,KAAK,KAAK;AAAA,EAC9B;AACA,SAAO;AACX;AACA,IAAM,gBAAgB,CAAC,SAAS,gBAAgB,eAAe,CAAC,OAAO;AAAA,EACnE,KAAK,CAAC,QAAQ,KAAK,aAAa;AAC5B,QAAI,QAAQ,UAAU;AAClB,aAAO;AAAA,IACX;AACA,QAAI,QAAQ,eAAe;AACvB,aAAO,QAAQ;AAAA,IACnB;AACA,QAAI,QAAQ,cAAc;AACtB,aAAO;AAAA,IACX;AACA,QAAI,QAAQ,iBAAiB;AACzB,aAAO;AAAA,IACX;AACA,QAAI,QAAQ,QAAQ,IAAI,QAAQ,KAAK,QAAQ;AAC7C,QAAI,CAACG,UAAS,KAAK,GAAG;AAClB,aAAO;AAAA,IACX;AACA,QAAI,CAAC,MAAM,QAAQ,GAAG;AAClB,YAAM,UAAU,CAAC,GAAG,cAAc,GAAG;AACrC,cAAQ,YAAY,SAAS,OAAO,gBAAgB,OAAO;AAC3D,aAAO,GAAG,IAAI;AAAA,IAClB;AACA,WAAO;AAAA,EACX;AAAA,EACA,KAAK,CAAC,QAAQ,KAAK,UAAU;AACzB,UAAM,UAAU,QAAQ,IAAI,QAAQ,KAAK,KAAK;AAE9C,QAAI,SAAS;AACT,YAAM,cAAcH,SAAQ,MAAM;AAClC,UAAI,iBAAiB;AACrB,UAAI,EAAE,SAAS,SAAS,QAAAM,QAAO,IAAI;AACnC,UAAI;AACJ,UAAI,QAAQ;AACZ,iBAAW,WAAW,cAAc;AAChC,kBAAU,MAAM,SAAS,OAAO;AAChC,YAAI,eAAe,UAAU,aAAa,SAAS,GAAG;AAClD,6BAAmB;AACnB;AAAA,QACJ;AACA,YAAIN,SAAQM,OAAM,GAAG;AACjB,2BAAiB;AAAA,QACrB;AACA,QAAAA,UAASA,QAAO,OAAO;AACvB;AAAA,MACJ;AACA,UAAI,gBAAgB;AAMhB,kBAAU,OAAO;AACjB,eAAO;AAAA,MACX;AACA,UAAI,cAAc,CAAC;AACnB,UAAI;AACJ,UAAI,aAAa;AACb,qBAAa;AACb,sBAAc,QAAQ,IAAI,WAAS,MAAM,eAAe,CAAC;AAAA,MAC7D,OACK;AACD,qBAAa,MAAM,SAAS,KAAK,WAAS,YAAY,KAAK,MAAM,eAAe,CAAC,CAAC;AAAA,MACtF;AACA,UAAI,WAAW,QAAQ,QAAQ,YAAY,aAAaA,SAAQ,KAAK,YAAY;AAKjF,UAAI,cAAc,QAAQ,GAAG;AACzB,mBAAW,MAAM,QAAQ;AAAA,MAC7B;AAEA,UAAI,eAAe,kBAAkB;AACjC,QAAAA,QAAO,gBAAgB,IAAI;AAAA,MAC/B,OACK;AACD,QAAAA,QAAO,GAAG,IAAI;AAAA,MAClB;AAAA,IACJ;AAEA,WAAO;AAAA,EACX;AAAA,EACA,gBAAgB,CAAC,QAAQ,QAAQ;AAC7B,UAAM,UAAU,QAAQ,eAAe,QAAQ,GAAG;AAElD,QAAI,SAAS;AACT,YAAM,cAAcN,SAAQ,MAAM;AAClC,UAAI;AACJ,UAAI,UAAU,QAAQ;AACtB,UAAIM,UAAS,QAAQ;AACrB,UAAI,QAAQ;AACZ,iBAAW,WAAW,cAAc;AAChC,kBAAU,QAAQ,IAAI,WAAS,MAAM,OAAO,CAAC;AAC7C,YAAI,eAAe,UAAU,aAAa,SAAS,GAAG;AAClD,6BAAmB;AACnB;AAAA,QACJ;AACA,QAAAA,UAASA,QAAO,OAAO;AACvB;AAAA,MACJ;AAGA,UAAI,QAAQ,KAAK,WAAU,OAAO,KAAM,GAAG;AACvC,YAAI,cAAc,CAAC;AACnB,YAAI;AACJ,YAAI,aAAa;AACb,uBAAa;AACb,wBAAc,QAAQ,IAAI,WAAS,MAAM,eAAe,CAAC;AAAA,QAC7D,OACK;AACD,uBAAa,MAAM,SAAS,KAAK,WAAS,YAAY,KAAK,MAAM,eAAe,CAAC,CAAC;AAAA,QACtF;AACA,YAAI,WAAW,QAAQ,QAAQ,YAAY,aAAaA,SAAQ,KAAK,YAAY;AACjF,YAAI,cAAc,QAAQ,GAAG;AACzB,qBAAW,MAAM,QAAQ;AAAA,QAC7B;AAEA,YAAI,eAAe,kBAAkB;AACjC,UAAAA,QAAO,gBAAgB,IAAI;AAAA,QAC/B,OACK;AACD,UAAAA,QAAO,GAAG,IAAI;AAAA,QAClB;AAAA,MACJ,OACK;AACD,eAAOA,QAAO,GAAG;AAAA,MACrB;AAAA,IACJ;AACA,WAAO;AAAA,EACX;AACJ;AAEA,IAAM,qBAAqB,CAACC,UAASD,UAAS,CAAC,MAAM;AACjD,QAAM,UAAU,CAAC;AACjB,MAAI,CAACA,SAAQ;AACT,IAAAA,UAAS,CAAC;AAAA,EACd;AACA,QAAM,UAAU;AAAA,IACZ,QAAAA;AAAA,IACA,SAAAC;AAAA,IACA;AAAA,EACJ;AACA,QAAM,UAAU,MAAM,UAAU,OAAO;AACvC,SAAO;AAAA,IACH;AAAA,IACA;AAAA,IACA,WAAW,CAAC,QAAQ,gBAAgBC,aAAY,UAAU;AACtD,YAAM,QAAQ,YAAY,SAAS,QAAQ,kBAAkB,CAAC,CAAC;AAC/D,UAAIA,YAAW;AACX,gBAAQ;AAAA,MACZ;AACA,aAAO;AAAA,IACX;AAAA,IACA,WAAW,CAAC,eAAeA,aAAY,SAAS;AAC5C,YAAM,QAAQ,QAAQ,UAAU,SAAO,QAAQ,iBAAiB,IAAI,YAAY,MAAM,aAAa;AACnG,UAAI,QAAQ,IAAI;AACZ,gBAAQ,OAAO,OAAO,CAAC;AACvB,YAAIA,YAAW;AACX,kBAAQ;AAAA,QACZ;AACA,eAAO;AAAA,MACX;AACA,aAAO;AAAA,IACX;AAAA,EACJ;AACJ;AAEA,SAAS,WAAW,SAAS,KAAK,MAAM,QAAQ;AAE5C,MAAI,mBAAmB,QAAQ;AAC3B,WAAO,iBAAiB,SAAS,KAAK,MAAM,MAAM;AAAA,EACtD;AACA,MAAI,WAAW,QAAQ;AACnB,WAAO,YAAY,SAAS,KAAK,MAAM,MAAM;AAAA,EACjD;AACA,SAAO,UAAU,SAAS,KAAK,MAAM,MAAM;AAC/C;AACA,SAAS,YAAY,SAAS,KAAK,MAAM,QAAQ;AAE7C,MAAIR,SAAQ,IAAI,GAAG;AACf,QAAK,MAAwC;AAEzC,cAAQ,KAAK,yDAAyD;AAAA,IAC1E;AAEA,WAAO,CAAC;AAAA,EACZ;AACA,SAAO,OAAO,KAAK,IAAI,EAClB,IAAI,CAAC,aAAa;AACnB,UAAM,cAAc;AAAA,MAChB,OAAO;AAAA,MACP;AAAA,IACJ;AACA,QAAI,OAAO,YAAY;AACnB,kBAAY,eAAe,OAAO,eAAe,OAAO,MAAM,OAAO;AAAA,IACzE,WACS,OAAO,qBAAqB;AACjC,YAAM,YAAY,OAAO,wBAAwB,OAAO,MAAM,OAAO;AACrE,kBAAY,WAAW,GAAG,SAAS,IAAI,QAAQ;AAC/C,kBAAY,WAAW,GAAG,SAAS,IAAI,QAAQ;AAAA,IACnD;AACA,WAAO,UAAU,SAAS,KAAK,KAAK,QAAQ,GAAG,QAAQ,WAAW;AAAA,EACtE,CAAC,EACI,KAAK;AACd;AACA,SAAS,UAAU,SAAS,KAAK,MAAM,SAAS,CAAC,GAAG,aAAa;AAE7D,QAAM,oBAAoB,CAAC,WAAW,QAAQ,YAAY;AAC1D,QAAM,eAAe,CAACS,SAAQ,iBAAiB,CAAC,KAAK,OAAO,GAAG,GAAGA,IAAG;AACrE,MAAIT,SAAQ,IAAI,GAAG;AACf,WAAO,KACF,IAAI,CAAC,UAAU;AAChB,aAAO,UAAU,SAAS,KAAK,OAAO,QAAQ,WAAW;AAAA,IAC7D,CAAC,EACI,KAAK;AAAA,EACd;AACA,QAAM,EAAE,MAAM,OAAO,OAAO,IAAI,IAAI;AACpC,MAAI,UAAU;AACd,MAAI,YAAY;AAChB,MAAI,QAAQ;AACZ,MAAIE,UAAS,IAAI,GAAG;AAChB,cAAU;AAAA,EACd,WACS,KAAK,YAAYF,SAAQ,KAAK,QAAQ,GAAG;AAC9C,gBAAY;AACZ,cAAU,KAAK,SAAS,IAAI,CAAC,UAAU;AACnC,YAAMU,QAAO,UAAU,SAAS,KAAK,OAAO,QAAQ,WAAW;AAC/D,UAAIV,SAAQU,KAAI,GAAG;AACf,eAAOA,MAAK,IAAI,CAAC,EAAE,OAAAC,OAAM,MAAMA,MAAK;AAAA,MACxC;AACA,aAAOD,MAAK;AAAA,IAChB,CAAC;AAAA,EACL,OACK;AACD,QAAI,IAAI;AACR,eAAW,oBAAoB,mBAAmB;AAC9C,UAAI,CAAC,WAAW,KAAK,gBAAgB,GAAG;AACpC,YAAI,MAAM,GAAG;AACT,oBAAU,KAAK,UAAU,KAAK,gBAAgB,CAAC;AAAA,QACnD,OACK;AACD,oBAAU,KAAK,gBAAgB;AAAA,QACnC;AACA,gBAAQ,IAAI;AACZ;AAAA,MACJ;AACA;AAAA,IACJ;AAAA,EACJ;AACA,QAAM,WAAY,eAAe,YAAY,YAAa;AAC1D,QAAM,WAAY,eAAe,YAAY,YAAa;AAC1D,MAAI,EAAE,OAAO,WAAW,IAAI;AAC5B,MAAI,CAAC,cAAc,OAAO,SAAS,UAAU;AACzC,iBAAa,EAAE,GAAG,KAAK;AACvB,WAAO,WAAW;AAClB,WAAO,WAAW;AAClB,WAAO,WAAW;AAElB,eAAW,QAAQ,mBAAmB;AAClC,aAAO,WAAW,IAAI;AAAA,IAC1B;AAAA,EACJ,WACS,CAAC,YAAY;AAClB,iBAAa,CAAC;AAAA,EAClB;AACA,MAAI,WAAW;AACX,cAAU,eAAe,SAAS,UAAU,SAAS,IAAI;AAAA,EAC7D,OACK;AACD,UAAM,qBAAqB,CAAC,CAAC,aAAa,oBAAoB;AAC9D,QAAI,EAAE,eAAe,IAAI;AACzB,QAAI,CAAC,kBAAkB,oBAAoB;AACvC,YAAM,CAAC,YAAY,IAAI,aAAa,YAAY;AAChD,uBAAiBR,UAAS,kBAAkB,IAAI,qBAAqB;AAAA,IACzE;AACA,QAAI,CAAC,gBAAgB;AACjB,gBAAU,eAAe,SAAS,UAAU,SAAS,IAAI;AAAA,IAC7D,OACK;AACD,YAAM,EAAE,UAAU,aAAa,IAAI;AACnC,UAAI,CAAC,UAAU;AACX,YAAI,cAAc;AACd,qBAAW,YAAY,IAAI;AAAA,QAC/B;AAAA,MACJ;AACA,iBAAW,cAAc,IAAI,eAAe,SAAS,UAAU,WAAW,cAAc,KAAK,SAAS,WAAW;AACjH,gBAAU;AAAA,IACd;AAAA,EACJ;AACA,QAAM,WAAW,eAAe,YAAY,eACtC,GAAG,YAAY,YAAY,IAAI,GAAG,KAClC;AAKN,MAAI,SAAS,SAAS;AAClB,eAAW,YAAY;AAAA,EAC3B;AAEA,QAAM,QAAQ,EAAE,UAAU,YAAY,WAAW,MAAS;AAC1D,SAAO;AAAA,IACH,IAAI,KAAK;AAAA,IACT;AAAA,EACJ;AACJ;AACA,SAAS,iBAAiB,SAAS,KAAK,MAAM,QAAQ;AAElD,QAAM,EAAE,cAAc,IAAI;AAC1B,MAAI,CAAC,eAAe;AAChB;AAAA,EACJ;AACA;AAGI,WAAO;AAAA,MACH,IAAI;AAAA,MACJ,OAAO,EAAE,OAAO,aAAa,IAAI,IAAI;AAAA,IACzC;AAAA,EACJ;AACJ;AACA,SAAS,eAAe,EAAE,UAAU,MAAM,GAAG,UAAU,SAAS,aAAa;AACzE,QAAM,OAAO,SAAS,MAAM,QAAQ;AACpC,MAAI,CAAC,QAAQ,CAACD,YAAW,IAAI,GAAG;AAC5B,WAAO;AAAA,EACX;AACA,QAAM,iBAAiB;AAAA,IACnB;AAAA,IACA;AAAA,EACJ;AACA,MAAI,eAAe,YAAY,OAAO;AAClC,UAAM,EAAE,OAAO,KAAK,IAAI;AACxB,mBAAe,KAAK,IAAI;AAAA,EAC5B;AACA,QAAM,cAAc,KAAK,cAAc;AACvC,MAAI,eAAe,YAAY,QAAQ;AACnC,UAAM,EAAE,SAAS,IAAI,YAAY,CAAC;AAClC,WAAO,WAAW,SAAS,SAAS,IAAI;AAAA,EAC5C;AACA,SAAO;AACX;AAEA,IAAM,YAAY,OAAO,WAAW,cAAc,OAAO,OAAO,gBAAgB;AAChF,IAAM,aAAa,CAAC;AAAA;AAAA,EAEpB,YACM,OAAQ,OAAyC,iBAAiB,OAAO,IAAI,KAC3E,OAAyC,iBAAiB,UAAU;AAAA;AAC5E,IAAM,gBAA8B,WAAY,OAAyC,gBAAgB,IAAI;AAK7G,SAAS,gBAAgB,QAAQ,WAAW,WAAW;AACnD,aAAW,OAAO,WAAW;AACzB,QAAI,EAAE,OAAO,YAAY;AACrB,aAAO,GAAG,IAAI,UAAU,GAAG;AAC3B;AAAA,IACJ;AAGA,QAAIE,UAAS,OAAO,GAAG,CAAC,GAAG;AACvB;AAAA,IACJ;AACA,QAAI,UAAU,GAAG,MAAM,UAAU,GAAG,GAAG;AACnC,aAAO,GAAG,IAAI,UAAU,GAAG;AAAA,IAC/B;AAAA,EACJ;AACA,aAAW,OAAO,WAAW;AACzB,QAAI,EAAE,OAAO,YAAY;AACrB,aAAO,OAAO,GAAG;AAAA,IACrB;AAAA,EACJ;AACJ;AAEA,SAAS,kBAAkB,IAAI;AAC3B,MAAI,CAAC,IAAI;AACL,SAAK,mBAAmB,KAAK;AAAA,EACjC;AACA,MAAI,CAAC,IAAI;AACL,WAAO;AAAA,EACX;AACA,SAAO,GAAG,WAAW,OAAO,iBAAiB;AACjD;AACA,SAAS,QAAQ,QAAQ,SAAS;AAC9B,QAAM,KAAK,mBAAmB,KAAK;AACnC,MAAI,CAAC,WAAW,IAAI;AAChB,cAAU,kBAAkB,EAAE;AAAA,EAClC;AACA,MAAI,CAAC,SAAS;AACV,UAAM,IAAI,MAAM,gCAAgC;AAAA,EACpD;AACA,MAAI,QAAQ,MAAM,GAAG;AACjB,UAAM,QAAQ,CAAC,WAAW,cAAc;AAEpC,sBAAgB,UAAU,MAAM,WAAW,SAAS;AAAA,IACxD,CAAC;AACD,aAAS,OAAO;AAAA,EACpB;AACA,QAAM,YAAY,QAAQ,QAAQ,QAAQ,EAAE;AAC5C,SAAO;AACX;AACA,SAAS,gBAAgB;AACrB,SAAO,OAAO,aAAa;AAC/B;AAEA,IAAM,eAAe,gBAAgB;AAAA,EACjC,MAAM;AAAA,EACN,cAAc;AAAA,EACd,MAAM,GAAG,EAAE,MAAM,GAAG;AAChB,WAAO,MAAM;AACT,YAAM,UAAU,kBAAkB;AAClC,UAAI,CAAC,SAAS;AACV;AAAA,MACJ;AACA,aAAO,QAAQ,OAAO,EAAE,MAAM,CAAC;AAAA,IACnC;AAAA,EACJ;AACJ,CAAC;AACD,IAAM,WAAW;AAEjB,IAAM,eAAe;AACrB,IAAM,SAAS,SAAS,CAAC,CAAC;AAC1B,SAAS,SAAS,WAAW,IAAI,QAAQ;AACrC,QAAM,QAASH,SAAQ,MAAM,IAAI,SAAS,CAAC,MAAM;AACjD,MAAI,CAAC,GAAG,SAAS,OAAO,GAAG;AACvB,UAAM,QAAQ,CAAC,UAAU;AACrB,UAAI,CAAC,MAAM,OAAO;AACd,cAAM,QAAQ,CAAC;AAAA,MACnB;AACA,YAAM,MAAM,YAAY,IAAI;AAAA,IAChC,CAAC;AAAA,EACL;AACA,MAAI,CAAC,UAAU,EAAE,GAAG;AAChB,cAAU,EAAE,IAAI,CAAC;AAAA,EACrB;AACA,YAAU,EAAE,EAAE,KAAK,GAAG,KAAK;AAC/B;AACA,IAAM,oBAAoB,CAAC,QAAQ,aAAa,YAAY,OAAO,QAAQ,QAAQ;AACnF,IAAM,cAAN,MAAkB;AAAA,EACd,YAAY,QAAQ,QAAQ,UAAU;AAClC,SAAK,eAAe;AACpB,SAAK,SAAS;AACd,SAAK,SAAS;AACd,QAAI,YAAY,WAAW,YAAYC,YAAW,SAAS,KAAK,GAAG;AAC/D,WAAK,WAAW;AAAA,IACpB;AAAA,EACJ;AAAA,EACA,QAAQ,KAAK;AACT,QAAI,UAAU,YAAY,QAAQ;AAClC,QAAI,OAAO,iBAAiB,eAAe;AAC3C,QAAI,QAAQ,eAAe,MAAM;AAAA,EACrC;AAAA,EACA,QAAQ,UAAU,IAAI;AAClB,QAAI,CAAC,IAAI;AACL,WAAK,mBAAmB,KAAK;AAAA,IACjC;AACA,UAAM,aAAc;AAAA,MAChB,SAAS,CAAC;AAAA,IACd;AACA,UAAM,iBAAiB,EAAE,GAAG;AAC5B,QAAI,KAAK,UAAU;AACf,WAAK,SAAS,MAAM,cAAc;AAAA,IACtC;AAEA,UAAM,OAAO,KAAK,OAAO,UAAU,UAAU,gBAAgB,IAAI;AACjE,UAAM,YAAY,CAAC,gBAAgB,WAAW,QAAQ,KAAK,WAAW;AACtE,UAAM,UAAU,CAAC,iBAAiB,KAAK,QAAQ,CAAC,CAAC,cAAc,MAAM,YAAY,EAAE;AACnF,QAAI,IAAI;AACJ,kBAAY,OAAO;AAAA,IACvB;AACA,WAAO;AAAA,MACH;AAAA,MACA;AAAA,MACA;AAAA,IACJ;AAAA,EACJ;AAAA,EACA,QAAQ,cAAc,MAAM,YAAY,IAAI;AACxC,QAAI,IAAI;AACJ,YAAM,EAAE,IAAI,IAAI,GAAG;AAEnB,UAAI,OAAO,IAAI,cAAc;AACzB,YAAI,WAAW,IAAI,iBAAiB,CAAC,YAAY;AAC7C,qBAAW,EAAE,aAAa,KAAK,SAAS;AACpC,gBAAI,CAAC,cAAc;AACf;AAAA,YACJ;AACA,yBAAa,QAAQ,CAAC,OAAO;AACzB,kBAAI,OAAO,OAAO,UAAU;AACxB,yBAAS,WAAW;AACpB,2BAAW;AACX,qBAAK,cAAc,cAAc,MAAM,UAAU;AAAA,cACrD;AAAA,YACJ,CAAC;AAAA,UACL;AAAA,QACJ,CAAC;AACD,iBAAS,QAAQ,IAAI,YAAY,EAAE,WAAW,KAAK,CAAC;AACpD;AAAA,MACJ;AAAA,IACJ;AACA,SAAK,cAAc,cAAc,MAAM,UAAU;AAAA,EACrD;AAAA,EACA,MAAM,cAAc,cAAc,MAAM,YAAY;AAChD,SAAK,OAAO,UAAU,IAAI;AAC1B,QAAI,CAAC,gBAAgB,YAAY;AAC7B,YAAM,QAAQ,IAAI,WAAW,QAAQ,IAAI,iBAAe,YAAY,CAAC,CAAC;AAAA,IAC1E;AAAA,EACJ;AAAA,EACA,OAAO,EAAE,MAAM,IAAI,CAAC,GAAG;AACnB,UAAM,YAAY,CAAC;AACnB,eAAW,OAAO,QAAQ;AACtB,YAAM,SAAS,KAAK,OAAO,GAAG,KAAK,CAAC;AACpC,UAAI,gBAAgB,WAAW,EAAE,UAAU,QAAQ,MAAM,GAAG,KAAK,OAAO,GAAG,GAAG,MAAM;AACpF,UAAI,CAAC,eAAe;AAChB;AAAA,MACJ;AACA,UAAI,CAACD,SAAQ,aAAa,GAAG;AACzB,wBAAgB,CAAC,aAAa;AAAA,MAClC;AACA,UAAI,YAAY,QAAQ,UAAU,OAAO,GAAG,EAAE;AAC9C,UAAI,CAAC,aAAa,QAAQ,QAAQ;AAC9B,oBAAY,OAAO;AAAA,MACvB;AACA,UAAI,CAAC,aAAa,mBAAmB,QAAQ;AACzC,oBAAY;AAAA,MAChB;AACA,iBAAW,EAAE,IAAI,MAAM,KAAK,eAAe;AACvC,iBAAS,WAAW,MAAM,aAAa,QAAQ,KAAK;AAAA,MACxD;AAAA,IACJ;AACA,QAAI,OAAO;AACP,iBAAW,YAAY,OAAO;AAC1B,cAAM,UAAU,aAAa,YAAY,SAAS;AAElD,YAAI,YAAY,UAAU,YAAY,QAAQ;AAC1C;AAAA,QACJ;AACA,cAAM,OAAO,MAAM,QAAQ;AAC3B,YAAIC,YAAW,IAAI,GAAG;AAClB,mBAAS,WAAW,SAAS,KAAK,EAAE,UAAU,OAAO,CAAC,CAAC;AAAA,QAC3D;AAAA,MACJ;AAAA,IACJ;AACA,WAAO,OAAO,KAAK,SAAS,EAAE,IAAI,CAAC,OAAO;AACtC,aAAO,EAAE,UAAU,EAAE,GAAG,GAAG,UAAU,EAAE,CAAC;AAAA,IAC5C,CAAC;AAAA,EACL;AACJ;AACA,YAAY,SAAS,CAAC,QAAQ,aAAa;AACvC,QAAMM,WAAU,CAAC,SAAS,UAAUD,SAAQ,KAAK,iBAAiB;AAC9D,QAAIL,YAAW,QAAQ,GAAG;AACtB,aAAO,SAAS,SAAS,UAAUK,SAAQ,KAAK,YAAY;AAAA,IAChE;AACA,WAAO,SAAS,QAAQ,SAAS,UAAUA,SAAQ,KAAK,YAAY;AAAA,EACxE;AACA,QAAM,eAAe,mBAAmBC,UAAS,MAAM;AAEvD,QAAM,UAAU,IAAI,YAAY,QAAQ,cAAc,QAAQ;AAC9D,SAAO;AACX;AAGA,IAAM,EAAE,gBAAAK,gBAAe,IAAI;AAC3B,eAAe,uBAAuB,KAAK;AACvC,QAAM,MAAM,CAAC;AACb,QAAM,OAAO,MAAMA,gBAAe,KAAK,GAAG;AAE1C,MAAI,CAAC,IAAI,aAAa,CAAC,IAAI,UAAU,MAAM;AACvC,UAAMC,aAAY,IAAI,OAAO,iBAAiB,aAAa,OAAO;AAClE,UAAM,QAAQ,IAAIA,WAAU,IAAI,CAAC,aAAaD,gBAAe,UAAU,GAAG,CAAC,CAAC;AAAA,EAChF;AACA,QAAM,EAAE,UAAU,IAAI;AACtB,aAAW,UAAU,WAAW;AAC5B,QAAI,OAAO,SAAS,OAAO,GAAG;AAC1B,YAAM,MAAM,UAAU,MAAM;AAE5B,gBAAU,MAAM,IAAI,IAAI,MAAM,IAAI,QAAQ,GAAG,IAAI,GAAG,IAAI,QAAQ,GAAG,CAAC;AAAA,IACxE;AAAA,EACJ;AACA,SAAO,CAAC,MAAM,GAAG;AACrB;",
  "names": ["warn", "isArray", "isFunction", "isString", "isObject", "source", "keySources", "active", "resolve", "recompute", "key", "data", "vnode", "renderToString", "teleports"]
}
