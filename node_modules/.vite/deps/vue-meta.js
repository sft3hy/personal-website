import {
  Comment,
  Fragment,
  NOOP,
  Static,
  Teleport,
  Text,
  __esm,
  __export,
  __toCommonJS,
  createApp,
  createVNode,
  defineComponent,
  escapeHtml,
  escapeHtmlComment,
  getCurrentInstance,
  getGlobalThis,
  h,
  includeBooleanAttr,
  initDirectivesForSSR,
  init_shared_esm_bundler,
  init_vue_runtime_esm_bundler,
  inject,
  isArray,
  isBooleanAttr,
  isFunction,
  isObject,
  isOn,
  isPromise,
  isProxy,
  isRenderableAttrValue,
  isSSRSafeAttrName,
  isSVGTag,
  isString,
  isVoidTag,
  looseEqual,
  looseIndexOf,
  makeMap,
  markRaw,
  mergeProps,
  normalizeClass,
  normalizeStyle,
  onUnmounted,
  propsToAttrMap,
  reactive,
  ssrContextKey,
  ssrUtils,
  stringifyStyle,
  toDisplayString,
  warn,
  watch
} from "./chunk-KWLKRZUM.js";

// node_modules/@vue/server-renderer/dist/server-renderer.esm-bundler.js
var server_renderer_esm_bundler_exports = {};
__export(server_renderer_esm_bundler_exports, {
  pipeToNodeWritable: () => pipeToNodeWritable,
  pipeToWebWritable: () => pipeToWebWritable,
  renderToNodeStream: () => renderToNodeStream,
  renderToSimpleStream: () => renderToSimpleStream,
  renderToStream: () => renderToStream,
  renderToString: () => renderToString,
  renderToWebStream: () => renderToWebStream,
  ssrGetDirectiveProps: () => ssrGetDirectiveProps,
  ssrGetDynamicModelProps: () => ssrGetDynamicModelProps,
  ssrIncludeBooleanAttr: () => includeBooleanAttr,
  ssrInterpolate: () => ssrInterpolate,
  ssrLooseContain: () => ssrLooseContain,
  ssrLooseEqual: () => ssrLooseEqual,
  ssrRenderAttr: () => ssrRenderAttr,
  ssrRenderAttrs: () => ssrRenderAttrs,
  ssrRenderClass: () => ssrRenderClass,
  ssrRenderComponent: () => ssrRenderComponent,
  ssrRenderDynamicAttr: () => ssrRenderDynamicAttr,
  ssrRenderDynamicModel: () => ssrRenderDynamicModel,
  ssrRenderList: () => ssrRenderList,
  ssrRenderSlot: () => ssrRenderSlot,
  ssrRenderSlotInner: () => ssrRenderSlotInner,
  ssrRenderStyle: () => ssrRenderStyle,
  ssrRenderSuspense: () => ssrRenderSuspense,
  ssrRenderTeleport: () => ssrRenderTeleport,
  ssrRenderVNode: () => renderVNode
});
function ssrRenderAttrs(props, tag) {
  let ret = "";
  for (const key in props) {
    if (shouldIgnoreProp(key) || isOn(key) || tag === "textarea" && key === "value") {
      continue;
    }
    const value = props[key];
    if (key === "class") {
      ret += ` class="${ssrRenderClass(value)}"`;
    } else if (key === "style") {
      ret += ` style="${ssrRenderStyle(value)}"`;
    } else {
      ret += ssrRenderDynamicAttr(key, value, tag);
    }
  }
  return ret;
}
function ssrRenderDynamicAttr(key, value, tag) {
  if (!isRenderableAttrValue(value)) {
    return ``;
  }
  const attrKey = tag && (tag.indexOf("-") > 0 || isSVGTag(tag)) ? key : propsToAttrMap[key] || key.toLowerCase();
  if (isBooleanAttr(attrKey)) {
    return includeBooleanAttr(value) ? ` ${attrKey}` : ``;
  } else if (isSSRSafeAttrName(attrKey)) {
    return value === "" ? ` ${attrKey}` : ` ${attrKey}="${escapeHtml(value)}"`;
  } else {
    console.warn(
      `[@vue/server-renderer] Skipped rendering unsafe attribute name: ${attrKey}`
    );
    return ``;
  }
}
function ssrRenderAttr(key, value) {
  if (!isRenderableAttrValue(value)) {
    return ``;
  }
  return ` ${key}="${escapeHtml(value)}"`;
}
function ssrRenderClass(raw) {
  return escapeHtml(normalizeClass(raw));
}
function ssrRenderStyle(raw) {
  if (!raw) {
    return "";
  }
  if (isString(raw)) {
    return escapeHtml(raw);
  }
  const styles = normalizeStyle(raw);
  return escapeHtml(stringifyStyle(styles));
}
function ssrRenderComponent(comp, props = null, children = null, parentComponent = null, slotScopeId) {
  return renderComponentVNode(
    createVNode(comp, props, children),
    parentComponent,
    slotScopeId
  );
}
function ssrRenderSlot(slots, slotName, slotProps, fallbackRenderFn, push, parentComponent, slotScopeId) {
  push(`<!--[-->`);
  ssrRenderSlotInner(
    slots,
    slotName,
    slotProps,
    fallbackRenderFn,
    push,
    parentComponent,
    slotScopeId
  );
  push(`<!--]-->`);
}
function ssrRenderSlotInner(slots, slotName, slotProps, fallbackRenderFn, push, parentComponent, slotScopeId, transition) {
  const slotFn = slots[slotName];
  if (slotFn) {
    const slotBuffer = [];
    const bufferedPush = (item) => {
      slotBuffer.push(item);
    };
    const ret = slotFn(
      slotProps,
      bufferedPush,
      parentComponent,
      slotScopeId ? " " + slotScopeId : ""
    );
    if (isArray(ret)) {
      const validSlotContent = ensureValidVNode(ret);
      if (validSlotContent) {
        renderVNodeChildren(
          push,
          validSlotContent,
          parentComponent,
          slotScopeId
        );
      } else if (fallbackRenderFn) {
        fallbackRenderFn();
      }
    } else {
      let isEmptySlot = true;
      if (transition) {
        isEmptySlot = false;
      } else {
        for (let i = 0; i < slotBuffer.length; i++) {
          if (!isComment(slotBuffer[i])) {
            isEmptySlot = false;
            break;
          }
        }
      }
      if (isEmptySlot) {
        if (fallbackRenderFn) {
          fallbackRenderFn();
        }
      } else {
        let start = 0;
        let end = slotBuffer.length;
        if (transition && slotBuffer[0] === "<!--[-->" && slotBuffer[end - 1] === "<!--]-->") {
          start++;
          end--;
        }
        for (let i = start; i < end; i++) {
          push(slotBuffer[i]);
        }
      }
    }
  } else if (fallbackRenderFn) {
    fallbackRenderFn();
  }
}
function isComment(item) {
  if (typeof item !== "string" || !commentTestRE.test(item)) return false;
  if (item.length <= 8) return true;
  return !item.replace(commentRE, "").trim();
}
function ssrRenderTeleport(parentPush, contentRenderFn, target, disabled, parentComponent) {
  parentPush("<!--teleport start-->");
  const context = parentComponent.appContext.provides[ssrContextKey];
  const teleportBuffers = context.__teleportBuffers || (context.__teleportBuffers = {});
  const targetBuffer = teleportBuffers[target] || (teleportBuffers[target] = []);
  const bufferIndex = targetBuffer.length;
  let teleportContent;
  if (disabled) {
    contentRenderFn(parentPush);
    teleportContent = `<!--teleport start anchor--><!--teleport anchor-->`;
  } else {
    const { getBuffer, push } = createBuffer();
    push(`<!--teleport start anchor-->`);
    contentRenderFn(push);
    push(`<!--teleport anchor-->`);
    teleportContent = getBuffer();
  }
  targetBuffer.splice(bufferIndex, 0, teleportContent);
  parentPush("<!--teleport end-->");
}
function ssrInterpolate(value) {
  return escapeHtml(toDisplayString(value));
}
function pauseTracking() {
  trackStack.push(shouldTrack);
  shouldTrack = false;
}
function resetTracking() {
  const last = trackStack.pop();
  shouldTrack = last === void 0 ? true : last;
}
function toRaw(observed) {
  const raw = observed && observed["__v_raw"];
  return raw ? toRaw(raw) : observed;
}
function isRef(r) {
  return !!(r && r.__v_isRef === true);
}
function pushWarningContext(vnode) {
  stack.push(vnode);
}
function popWarningContext() {
  stack.pop();
}
function warn$1(msg, ...args) {
  if (isWarning) return;
  isWarning = true;
  pauseTracking();
  const instance = stack.length ? stack[stack.length - 1].component : null;
  const appWarnHandler = instance && instance.appContext.config.warnHandler;
  const trace = getComponentTrace();
  if (appWarnHandler) {
    callWithErrorHandling(
      appWarnHandler,
      instance,
      11,
      [
        // eslint-disable-next-line no-restricted-syntax
        msg + args.map((a) => {
          var _a, _b;
          return (_b = (_a = a.toString) == null ? void 0 : _a.call(a)) != null ? _b : JSON.stringify(a);
        }).join(""),
        instance && instance.proxy,
        trace.map(
          ({ vnode }) => `at <${formatComponentName(instance, vnode.type)}>`
        ).join("\n"),
        trace
      ]
    );
  } else {
    const warnArgs = [`[Vue warn]: ${msg}`, ...args];
    if (trace.length && // avoid spamming console during tests
    true) {
      warnArgs.push(`
`, ...formatTrace(trace));
    }
    console.warn(...warnArgs);
  }
  resetTracking();
  isWarning = false;
}
function getComponentTrace() {
  let currentVNode = stack[stack.length - 1];
  if (!currentVNode) {
    return [];
  }
  const normalizedStack = [];
  while (currentVNode) {
    const last = normalizedStack[0];
    if (last && last.vnode === currentVNode) {
      last.recurseCount++;
    } else {
      normalizedStack.push({
        vnode: currentVNode,
        recurseCount: 0
      });
    }
    const parentInstance = currentVNode.component && currentVNode.component.parent;
    currentVNode = parentInstance && parentInstance.vnode;
  }
  return normalizedStack;
}
function formatTrace(trace) {
  const logs = [];
  trace.forEach((entry, i) => {
    logs.push(...i === 0 ? [] : [`
`], ...formatTraceEntry(entry));
  });
  return logs;
}
function formatTraceEntry({ vnode, recurseCount }) {
  const postfix = recurseCount > 0 ? `... (${recurseCount} recursive calls)` : ``;
  const isRoot = vnode.component ? vnode.component.parent == null : false;
  const open = ` at <${formatComponentName(
    vnode.component,
    vnode.type,
    isRoot
  )}`;
  const close = `>` + postfix;
  return vnode.props ? [open, ...formatProps(vnode.props), close] : [open + close];
}
function formatProps(props) {
  const res = [];
  const keys = Object.keys(props);
  keys.slice(0, 3).forEach((key) => {
    res.push(...formatProp(key, props[key]));
  });
  if (keys.length > 3) {
    res.push(` ...`);
  }
  return res;
}
function formatProp(key, value, raw) {
  if (isString(value)) {
    value = JSON.stringify(value);
    return raw ? value : [`${key}=${value}`];
  } else if (typeof value === "number" || typeof value === "boolean" || value == null) {
    return raw ? value : [`${key}=${value}`];
  } else if (isRef(value)) {
    value = formatProp(key, toRaw(value.value), true);
    return raw ? value : [`${key}=Ref<`, value, `>`];
  } else if (isFunction(value)) {
    return [`${key}=fn${value.name ? `<${value.name}>` : ``}`];
  } else {
    value = toRaw(value);
    return raw ? value : [`${key}=`, value];
  }
}
function callWithErrorHandling(fn, instance, type, args) {
  try {
    return args ? fn(...args) : fn();
  } catch (err) {
    handleError(err, instance, type);
  }
}
function handleError(err, instance, type, throwInDev = true) {
  const contextVNode = instance ? instance.vnode : null;
  if (instance) {
    let cur = instance.parent;
    const exposedInstance = instance.proxy;
    const errorInfo = true ? ErrorTypeStrings[type] : `https://vuejs.org/error-reference/#runtime-${type}`;
    while (cur) {
      const errorCapturedHooks = cur.ec;
      if (errorCapturedHooks) {
        for (let i = 0; i < errorCapturedHooks.length; i++) {
          if (errorCapturedHooks[i](err, exposedInstance, errorInfo) === false) {
            return;
          }
        }
      }
      cur = cur.parent;
    }
    const appErrorHandler = instance.appContext.config.errorHandler;
    if (appErrorHandler) {
      pauseTracking();
      callWithErrorHandling(
        appErrorHandler,
        null,
        10,
        [err, exposedInstance, errorInfo]
      );
      resetTracking();
      return;
    }
  }
  logError(err, type, contextVNode, throwInDev);
}
function logError(err, type, contextVNode, throwInDev = true) {
  if (true) {
    const info = ErrorTypeStrings[type];
    if (contextVNode) {
      pushWarningContext(contextVNode);
    }
    warn$1(`Unhandled error${info ? ` during execution of ${info}` : ``}`);
    if (contextVNode) {
      popWarningContext();
    }
    if (throwInDev) {
      throw err;
    } else {
      console.error(err);
    }
  } else {
    console.error(err);
  }
}
function getComponentName(Component, includeInferred = true) {
  return isFunction(Component) ? Component.displayName || Component.name : Component.name || includeInferred && Component.__name;
}
function formatComponentName(instance, Component, isRoot = false) {
  let name = getComponentName(Component);
  if (!name && Component.__file) {
    const match = Component.__file.match(/([^/\\]+)\.\w+$/);
    if (match) {
      name = match[1];
    }
  }
  if (!name && instance && instance.parent) {
    const inferFromRegistry = (registry) => {
      for (const key in registry) {
        if (registry[key] === Component) {
          return key;
        }
      }
    };
    name = inferFromRegistry(
      instance.components || instance.parent.type.components
    ) || inferFromRegistry(instance.appContext.components);
  }
  return name ? classify(name) : isRoot ? `App` : `Anonymous`;
}
function ssrRenderList(source, renderItem) {
  if (isArray(source) || isString(source)) {
    for (let i = 0, l = source.length; i < l; i++) {
      renderItem(source[i], i);
    }
  } else if (typeof source === "number") {
    if (!Number.isInteger(source)) {
      warn2(`The v-for range expect an integer value but got ${source}.`);
      return;
    }
    for (let i = 0; i < source; i++) {
      renderItem(i + 1, i);
    }
  } else if (isObject(source)) {
    if (source[Symbol.iterator]) {
      const arr = Array.from(source);
      for (let i = 0, l = arr.length; i < l; i++) {
        renderItem(arr[i], i);
      }
    } else {
      const keys = Object.keys(source);
      for (let i = 0, l = keys.length; i < l; i++) {
        const key = keys[i];
        renderItem(source[key], key, i);
      }
    }
  }
}
async function ssrRenderSuspense(push, { default: renderContent }) {
  if (renderContent) {
    renderContent();
  } else {
    push(`<!---->`);
  }
}
function ssrGetDirectiveProps(instance, dir, value, arg, modifiers = {}) {
  if (typeof dir !== "function" && dir.getSSRProps) {
    return dir.getSSRProps(
      {
        dir,
        instance: ssrUtils.getComponentPublicInstance(instance.$),
        value,
        oldValue: void 0,
        arg,
        modifiers
      },
      null
    ) || {};
  }
  return {};
}
function ssrLooseContain(arr, value) {
  return looseIndexOf(arr, value) > -1;
}
function ssrRenderDynamicModel(type, model, value) {
  switch (type) {
    case "radio":
      return looseEqual(model, value) ? " checked" : "";
    case "checkbox":
      return (isArray(model) ? ssrLooseContain(model, value) : model) ? " checked" : "";
    default:
      return ssrRenderAttr("value", model);
  }
}
function ssrGetDynamicModelProps(existingProps = {}, model) {
  const { type, value } = existingProps;
  switch (type) {
    case "radio":
      return looseEqual(model, value) ? { checked: true } : null;
    case "checkbox":
      return (isArray(model) ? ssrLooseContain(model, value) : model) ? { checked: true } : null;
    default:
      return { value: model };
  }
}
function ssrCompile(template, instance) {
  {
    throw new Error(
      `On-the-fly template compilation is not supported in the ESM build of @vue/server-renderer. All templates must be pre-compiled into render functions.`
    );
  }
}
function createBuffer() {
  let appendable = false;
  const buffer = [];
  return {
    getBuffer() {
      return buffer;
    },
    push(item) {
      const isStringItem = isString(item);
      if (appendable && isStringItem) {
        buffer[buffer.length - 1] += item;
        return;
      }
      buffer.push(item);
      appendable = isStringItem;
      if (isPromise(item) || isArray(item) && item.hasAsync) {
        buffer.hasAsync = true;
      }
    }
  };
}
function renderComponentVNode(vnode, parentComponent = null, slotScopeId) {
  const instance = createComponentInstance(vnode, parentComponent, null);
  const res = setupComponent(
    instance,
    true
    /* isSSR */
  );
  const hasAsyncSetup = isPromise(res);
  const prefetches = instance.sp;
  if (hasAsyncSetup || prefetches) {
    let p = hasAsyncSetup ? res : Promise.resolve();
    if (prefetches) {
      p = p.then(
        () => Promise.all(
          prefetches.map((prefetch) => prefetch.call(instance.proxy))
        )
      ).catch(NOOP);
    }
    return p.then(() => renderComponentSubTree(instance, slotScopeId));
  } else {
    return renderComponentSubTree(instance, slotScopeId);
  }
}
function renderComponentSubTree(instance, slotScopeId) {
  const comp = instance.type;
  const { getBuffer, push } = createBuffer();
  if (isFunction(comp)) {
    let root = renderComponentRoot(instance);
    if (!comp.props) {
      for (const key in instance.attrs) {
        if (key.startsWith(`data-v-`)) {
          (root.props || (root.props = {}))[key] = ``;
        }
      }
    }
    renderVNode(push, instance.subTree = root, instance, slotScopeId);
  } else {
    if ((!instance.render || instance.render === NOOP) && !instance.ssrRender && !comp.ssrRender && isString(comp.template)) {
      comp.ssrRender = ssrCompile(comp.template);
    }
    for (const e of instance.scope.effects) {
      if (e.computed) {
        e.computed._dirty = true;
        e.computed._cacheable = true;
      }
    }
    const ssrRender = instance.ssrRender || comp.ssrRender;
    if (ssrRender) {
      let attrs = instance.inheritAttrs !== false ? instance.attrs : void 0;
      let hasCloned = false;
      let cur = instance;
      while (true) {
        const scopeId = cur.vnode.scopeId;
        if (scopeId) {
          if (!hasCloned) {
            attrs = { ...attrs };
            hasCloned = true;
          }
          attrs[scopeId] = "";
        }
        const parent = cur.parent;
        if (parent && parent.subTree && parent.subTree === cur.vnode) {
          cur = parent;
        } else {
          break;
        }
      }
      if (slotScopeId) {
        if (!hasCloned) attrs = { ...attrs };
        const slotScopeIdList = slotScopeId.trim().split(" ");
        for (let i = 0; i < slotScopeIdList.length; i++) {
          attrs[slotScopeIdList[i]] = "";
        }
      }
      const prev = setCurrentRenderingInstance(instance);
      try {
        ssrRender(
          instance.proxy,
          push,
          instance,
          attrs,
          // compiler-optimized bindings
          instance.props,
          instance.setupState,
          instance.data,
          instance.ctx
        );
      } finally {
        setCurrentRenderingInstance(prev);
      }
    } else if (instance.render && instance.render !== NOOP) {
      renderVNode(
        push,
        instance.subTree = renderComponentRoot(instance),
        instance,
        slotScopeId
      );
    } else {
      const componentName = comp.name || comp.__file || `<Anonymous>`;
      warn(`Component ${componentName} is missing template or render function.`);
      push(`<!---->`);
    }
  }
  return getBuffer();
}
function renderVNode(push, vnode, parentComponent, slotScopeId) {
  const { type, shapeFlag, children } = vnode;
  switch (type) {
    case Text:
      push(escapeHtml(children));
      break;
    case Comment:
      push(
        children ? `<!--${escapeHtmlComment(children)}-->` : `<!---->`
      );
      break;
    case Static:
      push(children);
      break;
    case Fragment:
      if (vnode.slotScopeIds) {
        slotScopeId = (slotScopeId ? slotScopeId + " " : "") + vnode.slotScopeIds.join(" ");
      }
      push(`<!--[-->`);
      renderVNodeChildren(
        push,
        children,
        parentComponent,
        slotScopeId
      );
      push(`<!--]-->`);
      break;
    default:
      if (shapeFlag & 1) {
        renderElementVNode(push, vnode, parentComponent, slotScopeId);
      } else if (shapeFlag & 6) {
        push(renderComponentVNode(vnode, parentComponent, slotScopeId));
      } else if (shapeFlag & 64) {
        renderTeleportVNode(push, vnode, parentComponent, slotScopeId);
      } else if (shapeFlag & 128) {
        renderVNode(push, vnode.ssContent, parentComponent, slotScopeId);
      } else {
        warn(
          "[@vue/server-renderer] Invalid VNode type:",
          type,
          `(${typeof type})`
        );
      }
  }
}
function renderVNodeChildren(push, children, parentComponent, slotScopeId) {
  for (let i = 0; i < children.length; i++) {
    renderVNode(push, normalizeVNode(children[i]), parentComponent, slotScopeId);
  }
}
function renderElementVNode(push, vnode, parentComponent, slotScopeId) {
  const tag = vnode.type;
  let { props, children, shapeFlag, scopeId, dirs } = vnode;
  let openTag = `<${tag}`;
  if (dirs) {
    props = applySSRDirectives(vnode, props, dirs);
  }
  if (props) {
    openTag += ssrRenderAttrs(props, tag);
  }
  if (scopeId) {
    openTag += ` ${scopeId}`;
  }
  let curParent = parentComponent;
  let curVnode = vnode;
  while (curParent && curVnode === curParent.subTree) {
    curVnode = curParent.vnode;
    if (curVnode.scopeId) {
      openTag += ` ${curVnode.scopeId}`;
    }
    curParent = curParent.parent;
  }
  if (slotScopeId) {
    openTag += ` ${slotScopeId}`;
  }
  push(openTag + `>`);
  if (!isVoidTag(tag)) {
    let hasChildrenOverride = false;
    if (props) {
      if (props.innerHTML) {
        hasChildrenOverride = true;
        push(props.innerHTML);
      } else if (props.textContent) {
        hasChildrenOverride = true;
        push(escapeHtml(props.textContent));
      } else if (tag === "textarea" && props.value) {
        hasChildrenOverride = true;
        push(escapeHtml(props.value));
      }
    }
    if (!hasChildrenOverride) {
      if (shapeFlag & 8) {
        push(escapeHtml(children));
      } else if (shapeFlag & 16) {
        renderVNodeChildren(
          push,
          children,
          parentComponent,
          slotScopeId
        );
      }
    }
    push(`</${tag}>`);
  }
}
function applySSRDirectives(vnode, rawProps, dirs) {
  const toMerge = [];
  for (let i = 0; i < dirs.length; i++) {
    const binding = dirs[i];
    const {
      dir: { getSSRProps }
    } = binding;
    if (getSSRProps) {
      const props = getSSRProps(binding, vnode);
      if (props) toMerge.push(props);
    }
  }
  return mergeProps(rawProps || {}, ...toMerge);
}
function renderTeleportVNode(push, vnode, parentComponent, slotScopeId) {
  const target = vnode.props && vnode.props.to;
  const disabled = vnode.props && vnode.props.disabled;
  if (!target) {
    if (!disabled) {
      warn(`[@vue/server-renderer] Teleport is missing target prop.`);
    }
    return [];
  }
  if (!isString(target)) {
    warn(
      `[@vue/server-renderer] Teleport target must be a query selector string.`
    );
    return [];
  }
  ssrRenderTeleport(
    push,
    (push2) => {
      renderVNodeChildren(
        push2,
        vnode.children,
        parentComponent,
        slotScopeId
      );
    },
    target,
    disabled || disabled === "",
    parentComponent
  );
}
function nestedUnrollBuffer(buffer, parentRet, startIndex) {
  if (!buffer.hasAsync) {
    return parentRet + unrollBufferSync$1(buffer);
  }
  let ret = parentRet;
  for (let i = startIndex; i < buffer.length; i += 1) {
    const item = buffer[i];
    if (isString(item)) {
      ret += item;
      continue;
    }
    if (isPromise(item)) {
      return item.then((nestedItem) => {
        buffer[i] = nestedItem;
        return nestedUnrollBuffer(buffer, ret, i);
      });
    }
    const result = nestedUnrollBuffer(item, ret, 0);
    if (isPromise(result)) {
      return result.then((nestedItem) => {
        buffer[i] = nestedItem;
        return nestedUnrollBuffer(buffer, "", i);
      });
    }
    ret = result;
  }
  return ret;
}
function unrollBuffer$1(buffer) {
  return nestedUnrollBuffer(buffer, "", 0);
}
function unrollBufferSync$1(buffer) {
  let ret = "";
  for (let i = 0; i < buffer.length; i++) {
    let item = buffer[i];
    if (isString(item)) {
      ret += item;
    } else {
      ret += unrollBufferSync$1(item);
    }
  }
  return ret;
}
async function renderToString(input, context = {}) {
  if (isVNode$1(input)) {
    return renderToString(createApp({ render: () => input }), context);
  }
  const vnode = createVNode(input._component, input._props);
  vnode.appContext = input._context;
  input.provide(ssrContextKey, context);
  const buffer = await renderComponentVNode(vnode);
  const result = await unrollBuffer$1(buffer);
  await resolveTeleports(context);
  if (context.__watcherHandles) {
    for (const unwatch of context.__watcherHandles) {
      unwatch();
    }
  }
  return result;
}
async function resolveTeleports(context) {
  if (context.__teleportBuffers) {
    context.teleports = context.teleports || {};
    for (const key in context.__teleportBuffers) {
      context.teleports[key] = await unrollBuffer$1(
        await Promise.all([context.__teleportBuffers[key]])
      );
    }
  }
}
async function unrollBuffer(buffer, stream) {
  if (buffer.hasAsync) {
    for (let i = 0; i < buffer.length; i++) {
      let item = buffer[i];
      if (isPromise(item)) {
        item = await item;
      }
      if (isString(item)) {
        stream.push(item);
      } else {
        await unrollBuffer(item, stream);
      }
    }
  } else {
    unrollBufferSync(buffer, stream);
  }
}
function unrollBufferSync(buffer, stream) {
  for (let i = 0; i < buffer.length; i++) {
    let item = buffer[i];
    if (isString(item)) {
      stream.push(item);
    } else {
      unrollBufferSync(item, stream);
    }
  }
}
function renderToSimpleStream(input, context, stream) {
  if (isVNode(input)) {
    return renderToSimpleStream(
      createApp({ render: () => input }),
      context,
      stream
    );
  }
  const vnode = createVNode(input._component, input._props);
  vnode.appContext = input._context;
  input.provide(ssrContextKey, context);
  Promise.resolve(renderComponentVNode(vnode)).then((buffer) => unrollBuffer(buffer, stream)).then(() => resolveTeleports(context)).then(() => {
    if (context.__watcherHandles) {
      for (const unwatch of context.__watcherHandles) {
        unwatch();
      }
    }
  }).then(() => stream.push(null)).catch((error) => {
    stream.destroy(error);
  });
  return stream;
}
function renderToStream(input, context = {}) {
  console.warn(
    `[@vue/server-renderer] renderToStream is deprecated - use renderToNodeStream instead.`
  );
  return renderToNodeStream(input, context);
}
function renderToNodeStream(input, context = {}) {
  {
    throw new Error(
      `ESM build of renderToStream() does not support renderToNodeStream(). Use pipeToNodeWritable() with an existing Node.js Writable stream instance instead.`
    );
  }
}
function pipeToNodeWritable(input, context = {}, writable) {
  renderToSimpleStream(input, context, {
    push(content) {
      if (content != null) {
        writable.write(content);
      } else {
        writable.end();
      }
    },
    destroy(err) {
      writable.destroy(err);
    }
  });
}
function renderToWebStream(input, context = {}) {
  if (typeof ReadableStream !== "function") {
    throw new Error(
      `ReadableStream constructor is not available in the global scope. If the target environment does support web streams, consider using pipeToWebWritable() with an existing WritableStream instance instead.`
    );
  }
  const encoder = new TextEncoder();
  let cancelled = false;
  return new ReadableStream({
    start(controller) {
      renderToSimpleStream(input, context, {
        push(content) {
          if (cancelled) return;
          if (content != null) {
            controller.enqueue(encoder.encode(content));
          } else {
            controller.close();
          }
        },
        destroy(err) {
          controller.error(err);
        }
      });
    },
    cancel() {
      cancelled = true;
    }
  });
}
function pipeToWebWritable(input, context = {}, writable) {
  const writer = writable.getWriter();
  const encoder = new TextEncoder();
  let hasReady = false;
  try {
    hasReady = isPromise(writer.ready);
  } catch (e) {
  }
  renderToSimpleStream(input, context, {
    async push(content) {
      if (hasReady) {
        await writer.ready;
      }
      if (content != null) {
        return writer.write(encoder.encode(content));
      } else {
        return writer.close();
      }
    },
    destroy(err) {
      console.log(err);
      writer.close();
    }
  });
}
var shouldIgnoreProp, ensureValidVNode, commentTestRE, commentRE, shouldTrack, trackStack, stack, isWarning, ErrorTypeStrings, classifyRE, classify, warn2, ssrLooseEqual, createComponentInstance, setCurrentRenderingInstance, setupComponent, renderComponentRoot, normalizeVNode, isVNode$1, isVNode;
var init_server_renderer_esm_bundler = __esm({
  "node_modules/@vue/server-renderer/dist/server-renderer.esm-bundler.js"() {
    init_vue_runtime_esm_bundler();
    init_shared_esm_bundler();
    init_shared_esm_bundler();
    shouldIgnoreProp = makeMap(
      `,key,ref,innerHTML,textContent,ref_key,ref_for`
    );
    ({ ensureValidVNode } = ssrUtils);
    commentTestRE = /^<!--[\s\S]*-->$/;
    commentRE = /<!--[^]*?-->/gm;
    shouldTrack = true;
    trackStack = [];
    Symbol(true ? "iterate" : "");
    Symbol(true ? "Map key iterate" : "");
    stack = [];
    isWarning = false;
    ErrorTypeStrings = {
      ["sp"]: "serverPrefetch hook",
      ["bc"]: "beforeCreate hook",
      ["c"]: "created hook",
      ["bm"]: "beforeMount hook",
      ["m"]: "mounted hook",
      ["bu"]: "beforeUpdate hook",
      ["u"]: "updated",
      ["bum"]: "beforeUnmount hook",
      ["um"]: "unmounted hook",
      ["a"]: "activated hook",
      ["da"]: "deactivated hook",
      ["ec"]: "errorCaptured hook",
      ["rtc"]: "renderTracked hook",
      ["rtg"]: "renderTriggered hook",
      [0]: "setup function",
      [1]: "render function",
      [2]: "watcher getter",
      [3]: "watcher callback",
      [4]: "watcher cleanup function",
      [5]: "native event handler",
      [6]: "component event handler",
      [7]: "vnode hook",
      [8]: "directive hook",
      [9]: "transition hook",
      [10]: "app errorHandler",
      [11]: "app warnHandler",
      [12]: "ref function",
      [13]: "async component loader",
      [14]: "scheduler flush",
      [15]: "component update"
    };
    {
      const g = getGlobalThis();
      const registerGlobalSetter = (key, setter) => {
        let setters;
        if (!(setters = g[key])) setters = g[key] = [];
        setters.push(setter);
        return (v) => {
          if (setters.length > 1) setters.forEach((set) => set(v));
          else setters[0](v);
        };
      };
      registerGlobalSetter(
        `__VUE_INSTANCE_SETTERS__`,
        (v) => v
      );
      registerGlobalSetter(
        `__VUE_SSR_SETTERS__`,
        (v) => v
      );
    }
    classifyRE = /(?:^|[-_])(\w)/g;
    classify = (str) => str.replace(classifyRE, (c) => c.toUpperCase()).replace(/[-_]/g, "");
    warn2 = true ? warn$1 : NOOP;
    ssrLooseEqual = looseEqual;
    ({
      createComponentInstance,
      setCurrentRenderingInstance,
      setupComponent,
      renderComponentRoot,
      normalizeVNode
    } = ssrUtils);
    ({ isVNode: isVNode$1 } = ssrUtils);
    ({ isVNode } = ssrUtils);
    initDirectivesForSSR();
  }
});

// node_modules/vue-meta/dist/vue-meta.esm-bundler.js
init_vue_runtime_esm_bundler();
var resolveOption = (predicament) => (options, contexts) => {
  let resolvedIndex = -1;
  contexts.reduce((acc, context, index) => {
    const retval = predicament(acc, context);
    if (retval !== acc) {
      resolvedIndex = index;
      return retval;
    }
    return acc;
  }, void 0);
  if (resolvedIndex > -1) {
    return options[resolvedIndex];
  }
};
function setup(context) {
  let depth = 0;
  if (context.vm) {
    let { vm } = context;
    do {
      if (vm.parent) {
        depth++;
        vm = vm.parent;
      }
    } while (vm && vm.parent && vm !== vm.root);
  }
  context.depth = depth;
}
var resolve = resolveOption((acc, context) => {
  const { depth } = context;
  if (!acc || depth > acc) {
    return acc;
  }
});
var deepest = Object.freeze({
  __proto__: null,
  setup,
  resolve
});
var defaultConfig = {
  body: {
    tag: "script",
    to: "body"
  },
  base: {
    valueAttribute: "href"
  },
  charset: {
    tag: "meta",
    nameless: true,
    valueAttribute: "charset"
  },
  description: {
    tag: "meta"
  },
  og: {
    group: true,
    namespacedAttribute: true,
    tag: "meta",
    keyAttribute: "property"
  },
  twitter: {
    group: true,
    namespacedAttribute: true,
    tag: "meta"
  },
  htmlAttrs: {
    attributesFor: "html"
  },
  headAttrs: {
    attributesFor: "head"
  },
  bodyAttrs: {
    attributesFor: "body"
  }
};
var tags = {
  title: {
    attributes: false
  },
  base: {
    contentAsAttribute: true,
    attributes: ["href", "target"]
  },
  meta: {
    contentAsAttribute: true,
    keyAttribute: "name",
    attributes: ["content", "name", "http-equiv", "charset"]
  },
  link: {
    contentAsAttribute: true,
    attributes: [
      "href",
      "crossorigin",
      "rel",
      "media",
      "integrity",
      "hreflang",
      "type",
      "referrerpolicy",
      "sizes",
      "imagesrcset",
      "imagesizes",
      "as",
      "color"
    ]
  },
  style: {
    attributes: ["media"]
  },
  script: {
    attributes: [
      "src",
      "type",
      "nomodule",
      "async",
      "defer",
      "crossorigin",
      "integrity",
      "referrerpolicy"
    ]
  },
  noscript: {
    attributes: false
  }
};
function getTagConfigItem(tagOrName, key) {
  for (const name of tagOrName) {
    const tag = tags[name];
    if (name && tag) {
      return tag[key];
    }
  }
}
true ? Object.freeze({}) : {};
true ? Object.freeze([]) : [];
var isArray2 = Array.isArray;
var isFunction2 = (val) => typeof val === "function";
var isString2 = (val) => typeof val === "string";
var isObject2 = (val) => val !== null && typeof val === "object";
var objectToString = Object.prototype.toString;
var toTypeString = (value) => objectToString.call(value);
var isPlainObject = (val) => toTypeString(val) === "[object Object]";
var IS_PROXY = Symbol("kIsProxy");
var PROXY_SOURCES = Symbol("kProxySources");
var PROXY_TARGET = Symbol("kProxyTarget");
var RESOLVE_CONTEXT = Symbol("kResolveContext");
function clone(v) {
  if (isArray2(v)) {
    return v.map(clone);
  }
  if (isObject2(v)) {
    const res = {};
    for (const key in v) {
      if (key === "context") {
        res[key] = v[key];
      } else {
        res[key] = clone(v[key]);
      }
    }
    return res;
  }
  return v;
}
var pluck = (collection, key, callback) => {
  const plucked = [];
  for (const row of collection) {
    if (key in row) {
      plucked.push(row[key]);
      if (callback) {
        callback(row);
      }
    }
  }
  return plucked;
};
var allKeys = (source, ...sources) => {
  const keys = source ? Object.keys(source) : [];
  if (sources) {
    for (const source2 of sources) {
      if (!source2 || !isObject2(source2)) {
        continue;
      }
      for (const key in source2) {
        if (!keys.includes(key)) {
          keys.push(key);
        }
      }
    }
  }
  return keys;
};
var recompute = (context, sources, target, path = []) => {
  if (!path.length) {
    if (!target) {
      target = context.active;
    }
    if (!sources) {
      sources = context.sources;
    }
  }
  if (!target || !sources) {
    return;
  }
  const keys = allKeys(...sources);
  const targetKeys = Object.keys(target);
  for (const key of targetKeys) {
    if (!keys.includes(key)) {
      delete target[key];
    }
  }
  for (const key of keys) {
    if (isPlainObject(sources[0][key])) {
      if (!target[key]) {
        target[key] = {};
      }
      const keySources2 = [];
      for (const source of sources) {
        if (key in source) {
          keySources2.push(source[key]);
        }
      }
      recompute(context, keySources2, target[key], [...path, key]);
      continue;
    }
    if (!target[key] && isArray2(sources[0][key])) {
      target[key] = [];
    }
    const keyContexts = [];
    const keySources = pluck(sources, key, (source) => keyContexts.push(source[RESOLVE_CONTEXT]));
    let resolved = context.resolve(keySources, keyContexts, target[key], key, path);
    if (isPlainObject(resolved)) {
      resolved = clone(resolved);
    }
    target[key] = resolved;
  }
};
var createProxy = (context, target, resolveContext, pathSegments = []) => {
  const handler = createHandler(context, resolveContext, pathSegments);
  const proxy = markRaw(new Proxy(target, handler));
  if (!pathSegments.length && context.sources) {
    context.sources.push(proxy);
  }
  return proxy;
};
var createHandler = (context, resolveContext, pathSegments = []) => ({
  get: (target, key, receiver) => {
    if (key === IS_PROXY) {
      return true;
    }
    if (key === PROXY_SOURCES) {
      return context.sources;
    }
    if (key === PROXY_TARGET) {
      return target;
    }
    if (key === RESOLVE_CONTEXT) {
      return resolveContext;
    }
    let value = Reflect.get(target, key, receiver);
    if (!isObject2(value)) {
      return value;
    }
    if (!value[IS_PROXY]) {
      const keyPath = [...pathSegments, key];
      value = createProxy(context, value, resolveContext, keyPath);
      target[key] = value;
    }
    return value;
  },
  set: (target, key, value) => {
    const success = Reflect.set(target, key, value);
    if (success) {
      const isArrayItem = isArray2(target);
      let hasArrayParent = false;
      let { sources: proxies, active: active2 } = context;
      let activeSegmentKey;
      let index = 0;
      for (const segment of pathSegments) {
        proxies = pluck(proxies, segment);
        if (isArrayItem && index === pathSegments.length - 1) {
          activeSegmentKey = segment;
          break;
        }
        if (isArray2(active2)) {
          hasArrayParent = true;
        }
        active2 = active2[segment];
        index++;
      }
      if (hasArrayParent) {
        recompute(context);
        return success;
      }
      let keyContexts = [];
      let keySources;
      if (isArrayItem) {
        keySources = proxies;
        keyContexts = proxies.map((proxy) => proxy[RESOLVE_CONTEXT]);
      } else {
        keySources = pluck(proxies, key, (proxy) => keyContexts.push(proxy[RESOLVE_CONTEXT]));
      }
      let resolved = context.resolve(keySources, keyContexts, active2, key, pathSegments);
      if (isPlainObject(resolved)) {
        resolved = clone(resolved);
      }
      if (isArrayItem && activeSegmentKey) {
        active2[activeSegmentKey] = resolved;
      } else {
        active2[key] = resolved;
      }
    }
    return success;
  },
  deleteProperty: (target, key) => {
    const success = Reflect.deleteProperty(target, key);
    if (success) {
      const isArrayItem = isArray2(target);
      let activeSegmentKey;
      let proxies = context.sources;
      let active2 = context.active;
      let index = 0;
      for (const segment of pathSegments) {
        proxies = proxies.map((proxy) => proxy[segment]);
        if (isArrayItem && index === pathSegments.length - 1) {
          activeSegmentKey = segment;
          break;
        }
        active2 = active2[segment];
        index++;
      }
      if (proxies.some((proxy) => key in proxy)) {
        let keyContexts = [];
        let keySources;
        if (isArrayItem) {
          keySources = proxies;
          keyContexts = proxies.map((proxy) => proxy[RESOLVE_CONTEXT]);
        } else {
          keySources = pluck(proxies, key, (proxy) => keyContexts.push(proxy[RESOLVE_CONTEXT]));
        }
        let resolved = context.resolve(keySources, keyContexts, active2, key, pathSegments);
        if (isPlainObject(resolved)) {
          resolved = clone(resolved);
        }
        if (isArrayItem && activeSegmentKey) {
          active2[activeSegmentKey] = resolved;
        } else {
          active2[key] = resolved;
        }
      } else {
        delete active2[key];
      }
    }
    return success;
  }
});
var createMergedObject = (resolve2, active2 = {}) => {
  const sources = [];
  if (!active2) {
    active2 = {};
  }
  const context = {
    active: active2,
    resolve: resolve2,
    sources
  };
  const compute = () => recompute(context);
  return {
    context,
    compute,
    addSource: (source, resolveContext, recompute2 = false) => {
      const proxy = createProxy(context, source, resolveContext || {});
      if (recompute2) {
        compute();
      }
      return proxy;
    },
    delSource: (sourceOrProxy, recompute2 = true) => {
      const index = sources.findIndex((src) => src === sourceOrProxy || src[PROXY_TARGET] === sourceOrProxy);
      if (index > -1) {
        sources.splice(index, 1);
        if (recompute2) {
          compute();
        }
        return true;
      }
      return false;
    }
  };
};
function renderMeta(context, key, data, config) {
  if ("attributesFor" in config) {
    return renderAttributes(context, key, data, config);
  }
  if ("group" in config) {
    return renderGroup(context, key, data, config);
  }
  return renderTag(context, key, data, config);
}
function renderGroup(context, key, data, config) {
  if (isArray2(data)) {
    if (true) {
      console.warn("Specifying an array for group properties isnt supported");
    }
    return [];
  }
  return Object.keys(data).map((childKey) => {
    const groupConfig = {
      group: key,
      data
    };
    if (config.namespaced) {
      groupConfig.tagNamespace = config.namespaced === true ? key : config.namespaced;
    } else if (config.namespacedAttribute) {
      const namespace = config.namespacedAttribute === true ? key : config.namespacedAttribute;
      groupConfig.fullName = `${namespace}:${childKey}`;
      groupConfig.slotName = `${namespace}(${childKey})`;
    }
    return renderTag(context, key, data[childKey], config, groupConfig);
  }).flat();
}
function renderTag(context, key, data, config = {}, groupConfig) {
  const contentAttributes = ["content", "json", "rawContent"];
  const getTagConfig = (key2) => getTagConfigItem([tag, config.tag], key2);
  if (isArray2(data)) {
    return data.map((child) => {
      return renderTag(context, key, child, config, groupConfig);
    }).flat();
  }
  const { tag = config.tag || key } = data;
  let content = "";
  let hasChilds = false;
  let isRaw = false;
  if (isString2(data)) {
    content = data;
  } else if (data.children && isArray2(data.children)) {
    hasChilds = true;
    content = data.children.map((child) => {
      const data2 = renderTag(context, key, child, config, groupConfig);
      if (isArray2(data2)) {
        return data2.map(({ vnode: vnode2 }) => vnode2);
      }
      return data2.vnode;
    });
  } else {
    let i = 0;
    for (const contentAttribute of contentAttributes) {
      if (!content && data[contentAttribute]) {
        if (i === 1) {
          content = JSON.stringify(data[contentAttribute]);
        } else {
          content = data[contentAttribute];
        }
        isRaw = i > 1;
        break;
      }
      i++;
    }
  }
  const fullName = groupConfig && groupConfig.fullName || key;
  const slotName = groupConfig && groupConfig.slotName || key;
  let { attrs: attributes } = data;
  if (!attributes && typeof data === "object") {
    attributes = { ...data };
    delete attributes.tag;
    delete attributes.children;
    delete attributes.to;
    for (const attr of contentAttributes) {
      delete attributes[attr];
    }
  } else if (!attributes) {
    attributes = {};
  }
  if (hasChilds) {
    content = getSlotContent(context, slotName, content, data);
  } else {
    const contentAsAttribute = !!getTagConfig("contentAsAttribute");
    let { valueAttribute } = config;
    if (!valueAttribute && contentAsAttribute) {
      const [tagAttribute] = getTagConfig("attributes");
      valueAttribute = isString2(contentAsAttribute) ? contentAsAttribute : tagAttribute;
    }
    if (!valueAttribute) {
      content = getSlotContent(context, slotName, content, data);
    } else {
      const { nameless, keyAttribute } = config;
      if (!nameless) {
        if (keyAttribute) {
          attributes[keyAttribute] = fullName;
        }
      }
      attributes[valueAttribute] = getSlotContent(context, slotName, attributes[valueAttribute] || content, groupConfig);
      content = "";
    }
  }
  const finalTag = groupConfig && groupConfig.tagNamespace ? `${groupConfig.tagNamespace}:${tag}` : tag;
  if (isRaw && content) {
    attributes.innerHTML = content;
  }
  const vnode = h(finalTag, attributes, content || void 0);
  return {
    to: data.to,
    vnode
  };
}
function renderAttributes(context, key, data, config) {
  const { attributesFor } = config;
  if (!attributesFor) {
    return;
  }
  {
    return {
      to: "",
      vnode: h(`ssr-${attributesFor}`, data)
    };
  }
}
function getSlotContent({ metainfo, slots }, slotName, content, groupConfig) {
  const slot = slots && slots[slotName];
  if (!slot || !isFunction2(slot)) {
    return content;
  }
  const slotScopeProps = {
    content,
    metainfo
  };
  if (groupConfig && groupConfig.group) {
    const { group, data } = groupConfig;
    slotScopeProps[group] = data;
  }
  const slotContent = slot(slotScopeProps);
  if (slotContent && slotContent.length) {
    const { children } = slotContent[0];
    return children ? children.toString() : "";
  }
  return content;
}
var hasSymbol = typeof Symbol === "function" && typeof Symbol.toStringTag === "symbol";
var PolySymbol = (name) => (
  // vm = vue meta
  hasSymbol ? Symbol(true ? "[vue-meta]: " + name : name) : (true ? "[vue-meta]: " : "_vm_") + name
);
var metaActiveKey = PolySymbol(true ? "meta_active" : "ma");
function applyDifference(target, newSource, oldSource) {
  for (const key in newSource) {
    if (!(key in oldSource)) {
      target[key] = newSource[key];
      continue;
    }
    if (isObject2(target[key])) {
      continue;
    }
    if (newSource[key] !== oldSource[key]) {
      target[key] = newSource[key];
    }
  }
  for (const key in oldSource) {
    if (!(key in newSource)) {
      delete target[key];
    }
  }
}
function getCurrentManager(vm) {
  if (!vm) {
    vm = getCurrentInstance() || void 0;
  }
  if (!vm) {
    return void 0;
  }
  return vm.appContext.config.globalProperties.$metaManager;
}
function useMeta(source, manager) {
  const vm = getCurrentInstance() || void 0;
  if (!manager && vm) {
    manager = getCurrentManager(vm);
  }
  if (!manager) {
    throw new Error("No manager or current instance");
  }
  if (isProxy(source)) {
    watch(source, (newSource, oldSource) => {
      applyDifference(metaProxy.meta, newSource, oldSource);
    });
    source = source.value;
  }
  const metaProxy = manager.addMeta(source, vm);
  return metaProxy;
}
function useActiveMeta() {
  return inject(metaActiveKey);
}
var MetainfoImpl = defineComponent({
  name: "Metainfo",
  inheritAttrs: false,
  setup(_, { slots }) {
    return () => {
      const manager = getCurrentManager();
      if (!manager) {
        return;
      }
      return manager.render({ slots });
    };
  }
});
var Metainfo = MetainfoImpl;
var ssrAttribute = "data-vm-ssr";
var active = reactive({});
function addVnode(teleports, to, vnodes) {
  const nodes = isArray2(vnodes) ? vnodes : [vnodes];
  if (!to.endsWith("Attrs")) {
    nodes.forEach((vnode) => {
      if (!vnode.props) {
        vnode.props = {};
      }
      vnode.props[ssrAttribute] = true;
    });
  }
  if (!teleports[to]) {
    teleports[to] = [];
  }
  teleports[to].push(...nodes);
}
var createMetaManager = (config, resolver) => MetaManager.create(config, resolver);
var MetaManager = class {
  constructor(config, target, resolver) {
    this.ssrCleanedUp = false;
    this.config = config;
    this.target = target;
    if (resolver && "setup" in resolver && isFunction2(resolver.setup)) {
      this.resolver = resolver;
    }
  }
  install(app) {
    app.component("Metainfo", Metainfo);
    app.config.globalProperties.$metaManager = this;
    app.provide(metaActiveKey, active);
  }
  addMeta(metadata, vm) {
    if (!vm) {
      vm = getCurrentInstance() || void 0;
    }
    const metaGuards = {
      removed: []
    };
    const resolveContext = { vm };
    if (this.resolver) {
      this.resolver.setup(resolveContext);
    }
    const meta = this.target.addSource(metadata, resolveContext, true);
    const onRemoved = (removeGuard) => metaGuards.removed.push(removeGuard);
    const unmount = (ignoreGuards) => this.unmount(!!ignoreGuards, meta, metaGuards, vm);
    if (vm) {
      onUnmounted(unmount);
    }
    return {
      meta,
      onRemoved,
      unmount
    };
  }
  unmount(ignoreGuards, meta, metaGuards, vm) {
    if (vm) {
      const { $el } = vm.proxy;
      if ($el && $el.offsetParent) {
        let observer = new MutationObserver((records) => {
          for (const { removedNodes } of records) {
            if (!removedNodes) {
              continue;
            }
            removedNodes.forEach((el) => {
              if (el === $el && observer) {
                observer.disconnect();
                observer = void 0;
                this.reallyUnmount(ignoreGuards, meta, metaGuards);
              }
            });
          }
        });
        observer.observe($el.parentNode, { childList: true });
        return;
      }
    }
    this.reallyUnmount(ignoreGuards, meta, metaGuards);
  }
  async reallyUnmount(ignoreGuards, meta, metaGuards) {
    this.target.delSource(meta);
    if (!ignoreGuards && metaGuards) {
      await Promise.all(metaGuards.removed.map((removeGuard) => removeGuard()));
    }
  }
  render({ slots } = {}) {
    const teleports = {};
    for (const key in active) {
      const config = this.config[key] || {};
      let renderedNodes = renderMeta({ metainfo: active, slots }, key, active[key], config);
      if (!renderedNodes) {
        continue;
      }
      if (!isArray2(renderedNodes)) {
        renderedNodes = [renderedNodes];
      }
      let defaultTo = key !== "base" && active[key].to;
      if (!defaultTo && "to" in config) {
        defaultTo = config.to;
      }
      if (!defaultTo && "attributesFor" in config) {
        defaultTo = key;
      }
      for (const { to, vnode } of renderedNodes) {
        addVnode(teleports, to || defaultTo || "head", vnode);
      }
    }
    if (slots) {
      for (const slotName in slots) {
        const tagName = slotName === "default" ? "head" : slotName;
        if (tagName !== "head" && tagName !== "body") {
          continue;
        }
        const slot = slots[slotName];
        if (isFunction2(slot)) {
          addVnode(teleports, tagName, slot({ metainfo: active }));
        }
      }
    }
    return Object.keys(teleports).map((to) => {
      return h(Teleport, { to }, teleports[to]);
    });
  }
};
MetaManager.create = (config, resolver) => {
  const resolve2 = (options, contexts, active2, key, pathSegments) => {
    if (isFunction2(resolver)) {
      return resolver(options, contexts, active2, key, pathSegments);
    }
    return resolver.resolve(options, contexts, active2, key, pathSegments);
  };
  const mergedObject = createMergedObject(resolve2, active);
  const manager = new MetaManager(config, mergedObject, resolver);
  return manager;
};
var { renderToString: renderToString2 } = (init_server_renderer_esm_bundler(), __toCommonJS(server_renderer_esm_bundler_exports));
async function renderToStringWithMeta(app) {
  const ctx = {};
  const html = await renderToString2(app, ctx);
  if (!ctx.teleports || !ctx.teleports.head) {
    const teleports2 = app.config.globalProperties.$metaManager.render();
    await Promise.all(teleports2.map((teleport) => renderToString2(teleport, ctx)));
  }
  const { teleports } = ctx;
  for (const target in teleports) {
    if (target.endsWith("Attrs")) {
      const str = teleports[target];
      teleports[target] = str.slice(str.indexOf(" ") + 1, str.indexOf(">"));
    }
  }
  return [html, ctx];
}
export {
  createMetaManager,
  deepest as deepestResolver,
  defaultConfig,
  getCurrentManager,
  renderToStringWithMeta,
  resolveOption,
  useActiveMeta,
  useMeta
};
/*! Bundled license information:

@vue/server-renderer/dist/server-renderer.esm-bundler.js:
  (**
  * @vue/server-renderer v3.4.38
  * (c) 2018-present Yuxi (Evan) You and Vue contributors
  * @license MIT
  **)

vue-meta/dist/vue-meta.esm-bundler.js:
  (**
   * vue-meta v3.0.0-alpha.2
   * (c) 2021
   * - Pim (@pimlie)
   * - All the amazing contributors
   * @license MIT
   *)
*/
//# sourceMappingURL=vue-meta.js.map
